---
title: "CLAUDE CODE FULL COURSE 4 HOURS: Build & Sell (2026)"
date: 2026-02-12
video_id: QoQBzR1NIqI
channel: nick-saraev
---

Hey, this is the definitive course on Claude Code for beginners.
I use Claude Code every day to manage a business that does over $4 million a year in profit.
I also teach over 2,000 people how to use Claude Code, both for personal and then corporate
or professional tasks.
So this is more or less what I do all day.
Once you understand what I'm about to show you in this course, it's no small stretch
to say that Claude Code will augment your productivity.
You'll gain leverage in areas that you probably didn't even realize that you had, and that's
both for software engineering and also other parts of your life.
The focus here is not software per se, so you don't need to have a technical background
to understand what I'm going to tell you.
I'll make sure to start slow and build concepts on each other naturally and gradually so that
everybody here is on the same page.
So no fluff, here's what you guys are going to learn in this course.
We're going to start with the basics by downloading and then setting up Claude Code ourselves.
I'll then teach you all about integrated development environments or IDEs.
There's several on the market, and I'm going to walk you guys through the three most commonly
used ones so that we're all on the same page.
Afterwards, I'll show you how to set up your project brain, which is also known as the
cloud.md file.
Once we're done with that, we'll use Claude Code to actually build something because the
focus of this whole course is on practical building.
We'll build a simple web app hosted live on the internet, which I hope you guys learn
by doing, not just sitting around and listening to me.
After that, we'll cover the cloud directory, the subagents folder, and a bunch of functionality
that not a lot of people know about.
We'll then cover Claude Codes, various modes, including their plan mode, which you guys might
have heard about, dangerously skip permissions mode, which gained a fair amount of notoriety
recently, and how to use them, as well as use them safely.
We'll then cover complex project builds using plan mode and what I just showed you guys.
After that, we'll cover context management, which is quite the term right now.
I'll teach you guys all about how to manage your context efficiently, avoid context rot,
and ensure that your prompts are built and structured in a high ROI way.
I'll run you through every slash command and Claude Code and how to use all of them.
We'll then cover hooks, which are custom scripts that you guys can fire automatically
before or after every Claude Code tool call.
Very useful to know.
I'll then talk about Claude Code skills, which is basically how to create these skill files
that turn Claude Code into a bunch of different specialized agents.
We'll then cover model context protocol and how to set it up effectively.
I'll talk about a handful of automated systems that you guys can quickly build with model
context protocol, including email managers.
You can build your own bookkeeper and more.
I'll cover Claude Code plugins and marketplaces, the Chrome DevTools integration, which is
on a connection between Claude Code and Chrome that enables you to collect data from sources
that don't have APIs.
It's very, very valuable to learn.
We'll then cover Claude Code subagents with scoped tool access.
I'll talk about their new agent team feature and how to use them productively and then
get work trees and session mobility, which essentially will allow you to spin up parallel
cloud sessions without a lot of the downsides and issues that things like a cloud bot or
open cloud have unfortunately resulted in.
Finally, we'll cover scaling and deployment.
Basically, how to take your automations and run them in production using modal webhooks,
GitHub actions and Claude Code on the web.
So we've got quite a lot to cover.
Let's just dive right into it with the first, which is how to set up Claude Code as a total
beginner.
So the first thing we have to do is we actually have to purchase Claude Code.
And the reason why is because they don't offer it for their free plan at zero dollars.
In order to have access to Claude Code, you need at least their pro plan for everyday
productivity.
I'd recommend this if you guys are starting out.
The money that you spend on a subscription like this is.
So small compared to the massive productivity benefits that despite the fact that at 17
dollars, I personally would not even raise an eyebrow.
It's no small stretch to say that Claude Code probably delivers me productivity benefits
on the order of 10 to 15 thousand dollars a month, because it's not only just skilled
as a developer might be, which allows me to build systems that alleviate stresses and
strain in my life, but it's much more than a developer as well.
It's basically my second brain at this point.
After you click, try Claude, it'll take you to a page where you have to log in.
And once you're done, you can then create your account for the very first time.
So I'd select both of these.
I'm not going to subscribe to occasional product updates because my email inbox is
busy enough.
And then you have an onboarding screen with some personal information.
So I'm just going to fill that out.
And then once I'm done, circle back.
OK, so I'm Canadian.
And unfortunately, our dollars convert quite poorly to freedom dollars.
So the 17 dollars that we saw earlier is 28 dollars in my own currency.
I'm going to click Get Pro Plan and then walk through the payment details below.
Cool. And now I have a Claude subscription.
This is all that you need in order to get set up.
Everything else is totally free.
From here on out, the simplest way to get up and running with Claude code is just
opening up a terminal instance.
That'll seem pretty intimidating to a lot of you.
So I'm not just going to show you how to do it in the terminal.
I'm also going to show you how to do it using what's called their graphical user
interface, which they put together four or five months ago.
Any resource that I show you throughout this course is probably going to look a
little different by the time that you look at it versus when I'm looking at it.
And that's because Claude code, Anthropic and just AI tools in general change
really quickly, especially since most of the developers are also using Claude code.
So it kind of multiplies the productivity here.
What's important is not the specific layout, the colors, the words on the screen.
What's more important is that you just know how to find it.
And so the number one resource that I personally use to look up advanced Claude
code features is in the Claude code documentation.
It's at code dot Claude dot com slash docs, whatever language you speak,
just pump in there and then it'll automatically translate that over to.
So the Claude code docs specify that in order to install Claude code in your
system for the first time, you can run what's called a curl command here.
If you're running a Windows PowerShell, you know, you can run this Windows CMD.
You can run that just so we're all on the same page here.
When you have little snippets of text like this, what they're telling you to do
is basically to open up a terminal or a command prompt.
So on Mac OS, Linux or WSL, which are all different operating systems,
in order to open up a terminal, you just type terminal.
When you do so, you then get a terminal.
Now, this terminal might look a little intimidating to you if it's your first
time ever using something like that, but don't worry about it too much.
I just wanted to show you guys how easy it is to get set up with Claude code in this.
And then afterwards, as mentioned, we'll do the graphical user interface stuff.
OK, so this is what it looks like on Mac.
If you guys are on a Windows, then you'll have to use the Windows key search bar.
Then to look up something like CMD or command prompt.
At the end of it, you'll get something that looks pretty similar to this.
From here on out, all we have to do is we have to copy over the command that it gives us.
So because we want a native install and I'm in Mac OS,
I'm just going to copy over this command.
You can also click this little button over here and then alt tap back.
I'm going to paste it in and press enter from here on out.
A bunch of complicated things are going to occur.
If you don't already have it installed, may take you a little bit longer.
But now we're good to go.
Claude code is installed on our computer.
Once you're done with all that, all you have to do in order to use Claude
is just type the word Claude directly into your terminal.
It's really that easy.
Now, if it's the very first time that you're logging in, you'll also have to authenticate.
And it'll ask you to do so automatically when you open this stuff up.
If not, you can also type backslash L-O-G-I-N.
Once you click this, it'll tell you Claude code can be used with your Claude subscription
or build based on API usage through your console account.
How would you like to set up?
Now, in our case, we're using the cheapest, most effective method,
which is the Pro, Max, Team or Enterprise subscription.
It's also the most straightforward, which is why it's the one that I used in this course.
I'm just going to click Enter.
And then it'll then log you into your Claude account,
the one that you just set up a moment ago.
Once we're done, you're all set up for Claude code.
You can close this window, then Alt Tab back.
And you'll see that it's going to say just press Enter to continue.
Now, just so we're all on the same page here,
all we've really done so far is we've just opened up a chat interface with an AI model.
It's just instead of it being in like a nice desktop application or on the web,
it's in our terminal.
And the value here is instead of running an AI model on the web
or in some distant cloud server, what we're doing now is we're running it locally
on our computer.
So we actually have the ability to take this model
and then locally modify files on our computer, write scripts,
write stories, write poems, restructure our file organizer,
clean up our PC or our Mac.
Like this thing is currently connected to my computer.
And I'll run you guys through our permissions and all that stuff
work later on in the course, as talked about in the outline.
But even this alone makes it extraordinarily powerful.
So this screen can look pretty intimidating for beginners.
Most people end up using the terminal flow, not the GUI flow.
But I'm going to explain to you what you guys see here just for simplicity.
In the top left hand corner, you have that cute little Claude code widget.
I think it's I don't know if it's supposed to be a crab or like a jellyfish,
but it's adorable.
Then you have Claude code and the actual version up above.
Underneath, you have the model that you're currently using.
In my case, I'm using Opus 4.6.
Then you have the plan that you're on, in my case, Claude Mac.
So this is a couple levels up from the pro plan.
And then perhaps most importantly, you have the current working directory.
As I mentioned to you a moment ago, this is working inside of your computer
in a specific folder.
And so Claude code currently lives inside slash users slash Nick Sariah,
which is basically like the home folder, at least on my Mac OS.
Here is your previous command.
And so I just wrote clear because I wanted to clear it all the way up
and give you guys a fresh canvas.
Here is where you actually insert the text.
So when you type stuff, it pops up underneath here, it tells you the model again.
Then it gives you various modes.
So in my mode right now, I'm in bypass permissions.
This is sort of like a dangerous mode.
It's a mode that not a lot of people feel super comfortable with.
But it's the mode that I prefer for knowledge, work and intellectually
valuable tasks. And I'll run you guys through more of that later on.
But you can cycle through modes simply by clicking shift and tab,
which I'll show you guys how to do.
And then there's some additional information here.
There's some version, the latest and then over here is, at least in my case,
the token readout.
And you know, it's really cool.
You can actually adjust this.
This sort of thing is your Claude code status line, which I'm also going to run you through.
You can make it all colorful and all wonky and really fun.
You can have it display whatever the heck you want.
So the very first thing I'm going to do is I'm just going to say, hey,
how's it going?
And immediately after, I'm going to take a screenshot
so I can show you guys some more information.
So opening this up in my drawing tool, what ended up happening is immediately
after we said, hey, how's it going?
You see that another prompt showed up called finagling.
This is one of like a thousand different words that Claude code uses.
Basically, any time it's thinking, it's going to use some funny term like finagling
or processing or, I don't know,
rumpeting or considering or whatever the heck.
They're pretty funny. And the cool thing is you can customize that.
Next, you have the number of seconds that your query has lasted.
So I just said, hey, how's it going?
And then two seconds in, it's now produced five tokens for me.
And then finally, you also have the token count.
So just so we're all on the same page, a token is not the same as a word,
but at least for the purposes of most of what you do,
you can consider a token to be similar to a word.
For instance, I said, hey, how's it going?
This is not one, two, three, four.
This isn't four tokens.
It might be four words. It's probably closer to six or seven tokens.
But just think about tokens as being analogous to words.
Just a few more, if that makes sense.
You'll also see that an additional piece of information popped up down here
called context. And this is really important.
Context goes from zero to 100 percent.
And that's how much basically conversation history you have
in the current chat window with your current instance of Claude Code.
This becomes really important later when you're designing
better context management techniques,
which is a big portion of what this course is going to be all about,
because at least as of the time of this recording,
context management is sort of like the big bottleneck
in getting these systems to do more and better for you.
You'll also notice that on the right hand side, my token counter,
my status line here, it went up significantly.
And so basically what this means is at about 20,000 tokens or so,
or about 10 percent of the way through our entire conversation thread
that's allotted to us.
What's really cool is Claude Code will take all of that history
and at regular intervals, it'll actually compress that for you
by increasing the information density, taking a string of text
and then making it higher information density
and higher information density and higher information density successively.
So that even if you wrote something in kind of like a bloated way,
a way that you could have used fewer words to say,
as your context goes up and longer,
cloud will automatically manage that for you to ensure that you're within the window.
So that's how to set up Claude Code in the terminal.
Hopefully we're all on the same page.
Terminals are really similar to graphical user interfaces,
which I'm about to show you in a moment.
I do recommend that you guys get used to using it in terminal,
because when you use it in terminal, you basically unlock even more functionality.
You can run a bunch of these side by side.
You could run different terminal tools and whatnot
that give you guys faster refresh times.
And we'll cover that sort of stuff later.
But what I want to do now is I want to show you guys
how to run it in a graphical user interface.
And these graphical user interfaces are typically managed
by what's called an integrated development environment.
Well, that takes us to the next logical question, which is Nick,
what is an integrated development environment?
An integrated development environment, also termed IDE,
is basically three things put together.
OK, it's a file folder organizer plus a text editor.
Plus an AI chat widget,
similar to what you get if you go on chatgpd.com or cloud.ai.
So you know how on my Mac, if I go finder,
I open up a basically series of folders where I can select different files
and open them up and so on and so forth.
You can do the same thing on Windows.
If you just type in folder or I don't know, the C drive or whatnot.
Well, an IDE is basically that plus something like notepad or notes
plus something like chatgpt all in one.
And right now we have two major IDEs that the market is tending towards.
The first is called Visual Studio Code, and the second is called Antigravity.
Visual Studio Code is sort of like the OG one,
because Antigravity is actually built on it.
It was developed a lot longer by Microsoft.
It's really, really extensible.
It has great support and it's very straightforward.
So I'm going to show you guys how to set things up on it.
But Antigravity, I would consider to basically be Visual Studio 2.0.
So not only does it have most of the same features now,
although it is some of them are still kind of a little beta ish.
It's also a lot more modern.
And then there's a much bigger focus on AI,
which is obviously kind of the whole point of this course.
So I'm going to be showing you guys initially how to set things up in Visual Studio Code.
Then I'm going to do Antigravity.
And then for the rest of the course,
we're just going to be doing all of our work inside of Antigravity.
And Antigravity is really cool.
There's some additional functionality within Antigravity, not even tied to Claude Code.
So the first thing we need to do is obviously we need to set up Visual Studio Code.
In order to do that, just head over to Visual Studio Code on Google over here
and then download for whatever your specific application is.
In my case, I'm downloading the Mac OS.
I'm then going to have the download appear in the top right hand corner.
I'm then going to give that a click and then go download unverified file.
And then over here on a Mac, you again have to drag the little window over.
So I'm just going to do that.
And once you're done, you're going to have a page that looks something like this.
So remember earlier how I said it was like a file editor?
Well, that's what this little left hand side is about.
If I click open a folder, I can actually go through and I can open a folder on my computer.
So why don't I just go and open, I don't know, left click contact.
OK, so now I'm inside of the left click contact folder.
And you can see we have some files here, a gitignore,
clod.nd, contact, index and a Netlify.toml.
I'm going to go through all that sort of stuff in a moment.
It's not super important for now.
But this is sort of like where the file explorer functionality comes in.
If I were to click on one of these, as you can see, we've now opened up a big text editor
right in the middle of the screen.
And so this is a bunch of CSS.
It's a programming language.
What's really cool is with clod coding, I actually have to know how to read any of this stuff.
It'll just tell you everything.
And so that is the text editor functionality.
I can make changes.
Hey, what's up?
You know, I could create a new file here if I wanted to called message.md.
And I could say, hey, how's it going, YouTube?
So just like in that way, we basically have file editing functionality.
And then we can also select files to work on and stuff like that.
And then on the right hand side, you have an agent tab, which is where you have your
chat interface with AI.
Now, right out of the gate, the VS code chat interface isn't actually clod code.
In order to access clod code, you have to download it as an extension.
So I'm going to run you guys through that right now on the left hand side here.
Click on these little blocks, then just type clod code.
You'll see a variety of these.
The one that you're looking for is the one that's developed by Anthropic, the one
with that little check mark in it.
Be very wary of downloading extensions that are not from official
developers and vendors like Anthropic, simply because people have been known
to insert malware and different things like that in these.
So very important that you're that you preferentially use verified sources.
In my case, I've already installed this, but all you have to do is go through that
little installation wizard here.
And then once you're done, you will have access to clod code.
The question is, OK, I have access to clod code.
How do I actually use it?
Well, it's really easy.
If you just go to the top right hand corner of the Citadel agent window, you now can
just click on clod code.
But you'll also see that there's a clod logo up here as well.
Well, what the hell does this mean?
If you click on this, you'll open up just like another window.
And in my case, I open it up with the terminal default.
So it's going to open up this in the terminal.
This could be pretty intimidating and kind of annoying, to be honest, juggling all these
things. I'm just going to zoom in so it's easier for us to see.
So my recommendation is at least for beginners, just stick to the one on the right.
That one's simpler. And as you can see, it's a different user interface than the
terminal. OK, so how exactly do you use this and what are all of the different
features and buttons and stuff like that?
Covering the interface, obviously, up top, you have the past conversations tab.
And so as you build up more conversation history, you'll actually be able to jump
back to any prior conversation you've had with Claude code over here.
You can do that both locally and then on the Web.
I don't have access to either of these yet because I just set this up fresh for you
guys. Underneath that, you have the Claude code logo.
Underneath that, you have that cute little jellyfish or lobster, whatever the heck it
is. Underneath, you have your little chat window.
So here's where I can actually talk to Claude.
Hey, Claude, what's up?
Once we open this, you'll see that similarly to how we had before, we have that little
accomplishing fidgeting, whatever.
We have that little like process text come up.
After that, you then have the response.
The response comes in in this little window, although you'll see it's different when it
accesses files and stuff like that.
Underneath at the very bottom left hand corner, you have the various permission modes.
Remember how earlier, Mindset dangerously skipped permissions?
We can do the same thing here.
If you just click on this, you can cycle through all of the different possible modes.
And you see that little window around the chatbot also changes.
So in my case, I'm asking before edits, which means because this is running locally on my
computer, before it makes any changes to any local files, I'm going to say, hey, just ask
me to make sure. Now, this is pretty safe.
And a lot of people, especially coders and developers that are a little more old school,
will usually work like this.
But personally, given that when Claude's really in the thick of things, it's asking me for
edits every five fricking seconds.
If you really want to unlock that productivity, as I talked about before, you either use edit
automatically or use bypass permissions.
And I'll cover plan mode and whatnot later as well.
To the right of that is, and this is kind of intimidating for some people to understand, but
this is the file that is currently being fed in as context.
So, for instance, do you see how here it says index.html?
And if I click this, I get this little eye icon.
Well, if I leave this open, basically Claude is currently looking at this file.
So what file are you looking at right now?
It'll now tell me that it's looking through the index.html that's open in my editor.
It hasn't read through the contents yet because reading through the contents of this massive
file would feed a fair amount of tokens into context, which would charge me a fair amount of
money. So right now it's not doing any of that.
But suffice to say, I can actually edit this in real time.
Yes, change the title to Nick's YouTube example.
And what it's going to do is it's going to go through my file.
It's going to find the title, which is listed right over here.
And then it's going to change that for me.
This is an example of a really simple, easy and straightforward change.
But I could do way more.
I could refactor this whole thing from light dark mode to light mode.
So I'm actually going to ask it to do so.
Refactor this index.html from dark mode to light mode.
And if you don't know what this means, it's OK.
Bear with me. We're actually going to rebuild a whole app using Claude code and various
design patterns in a moment.
The first thing it'll do is it'll try planning out the changes that it's going to make.
And so it's doing a bunch of programmatic adjacent things right now, like it's filtering out
a bunch of different CSS snippets.
It's doing a fair amount of work here.
And you don't need to be a programmer to understand what's going on.
We basically now given this a task, it's deconstructing the task into a list of high level steps.
Then it's going to go through and it's actually going to present this plan to me for me to say yes or no to.
Now you'll notice that when I did this, in addition to the interface changing and now the colors being blue,
in the bottom right hand corner, we now have sort of a little pause button.
This pause button is pretty important because it allows us to actually stop a Claude code execution in process,
like while it's working.
So I could theoretically change this at any point in time.
OK, and I can actually pause it and then maybe I could give it some more instructions or, I don't know, tell it to do
something differently. So I'm actually going to click this little button, then I'm going to go to bypass permissions.
I'll say no plan, just do it.
And what I've done is I've interrupted the process and the tool call, and now it's going to go through and instead of
going to do this big fat plan, I'm just going to say it's the wild, wild west, buddy.
Just get in there and start making some changes.
When I did this, you'll notice that there's now a thinking tab that's open.
If you click on this, you can actually peer into the internal thoughts of Claude as it goes through and
accomplishes your request.
So in this case, it said the user wants me to just refactor the dark mode to light mode without planning.
Let me read the whole file, understand all the colors and then make the changes.
And as you see, we just had some changes made, which is what this little blue thing is here, showing that we've
made the changes.
So immediately after thinking, it then did some more thinking.
Then down at the very bottom, it's now updated a bunch of the sections of my code and it's continuing down some
little to-do list.
So this is how you interact with Claude code through the graphical user interface.
And there are a couple of additional things, like you can click on this button to attach files and folders and use
the browser. You can also check all of the commands here, which are pretty powerful stuff, and I'll cover them all in
due time. So that's Claude code in Visual Studio code, VS code.
Let's now cover how it looks in Anti-Gravity, how to set that up.
And then immediately after, we're going to build an actual real web app using Claude code.
As expected, Anti-Gravity is pretty similar.
They have a website here called anti-gravity.google.
It's very sexy and clean.
Wouldn't be surprised they built this with agents.
You just click download for whatever your specific operating system is, in my case, Mac OS with Apple Silicon.
I'm going to give that a click.
Then it'll go through that same process that we just did for VS code.
Once you open up Anti-Gravity, it looks very similar to what we just saw a moment ago with VS code.
And that's because the two are sort of built on each other.
So just like VS code was both a file explorer, a file editor, a notepad and an agent manager.
You can see here we have those three same ideas.
On the left hand side, we're going to have the folders.
On the middle, we're going to be able to edit the text of the files that we work with.
And then on the right hand side, we can actually talk to agents.
First thing I'm going to do is I'll click open folder and we'll go back to, I don't know, left click contact, just so you
guys could see what we're dealing with.
And you'll understand here that the UX is just slightly different than what we had earlier.
You know, some things are indented.
We have like some little cool symbols in the left hand side of the file.
This isn't super important, but I just think Anti-Gravity looks cleaner, which is why I like using it.
In the middle here, if I click this index.html, you'll see that we also have the text pop up just like we did earlier.
And the only real difference between Anti-Gravity and VS code is just what we have in this right hand side.
Earlier, we could have used Claude code really easily because there was an actual dedicated Claude code button.
Right now there isn't.
In order to access Claude code, assuming that you've installed it.
So I had over here Claude code for VS code.
Give that installation button a click.
Assuming that we've installed it, we have to do instead is we have to double click somewhere here and then click on this little Claude icon.
Okay.
And then just delete the agent icon.
And now you have the same layout that we had earlier in VS code.
Just now you have it with Claude code.
The reason why is just because Anti-Gravity is a Google product.
So they try and push the Google Gemini series of models.
That's what we had on the right hand side earlier.
And to be clear, this is a Claude code specific course, but you can also use whatever model you want to do, whatever purpose.
Like the model type is less important than just the fact that you're really good at using it and the fact that it's smart.
So exact same layout here.
Not going to cover it anymore.
Let's get into actually building some stuff.
So let's now build our very first app slash web page with Claude code.
For simplicity sake, I'm starting with probably the most straightforward build, which is just going to be a web page.
And we're not just going to do the hero header, which is the top or above the fold section.
We're going to do the whole website.
And the reason why I'm starting with this is because I just want everybody to understand how good Claude code and similar tools have gotten at being able to design high quality websites.
This is a site up here called godly.website.
And what it does is it basically just showcases really high quality design.
And every single one of these, with maybe just a couple of exceptions, is now doable in probably, I want to say less than 10 minutes or so, front to back using Claude code.
And this isn't me just pretending.
This is something that I have done myself dozens of times.
I've built really high quality websites.
The other day I built like 15 or so for a project.
They all look just like this.
So award winning design, award winning app functionality and stuff like that.
These are just a few of the things that you guys are going to learn today.
In addition, you're also going to learn how Claude.md, which is the system brain file, affects your prompts.
I'm going to run you guys through the three major ways that people currently design sites and the various ways that you guys could use these approaches to both design websites, apps, and more or less anything else you want.
And then I'm also going to talk a little bit about deploying.
So let's start with Claude.md.
I have open in antigravity here, the same workspace that we were looking at before, with just a couple of changes.
Namely, there's this node underscore modules folder here, which you guys don't have to pay attention to.
This is automatically generated by Claude code every time we use a library or use some sort of NPM package.
And then underneath we have Claude.md.
Now Claude.md, as mentioned, is the brain of your workspace.
To make it really, really simple and straightforward for you, because I think a lot of people misunderstand how Claude.mds work, let's just look at a hypothetical conversation.
Over here, let's say you are on the right hand side.
And so what you do is you say, hey, research X for me.
Research, I don't know, the best trending posts on Twitter in my niche, whatever the heck.
Right. And then what ends up happening is the model afterwards, Claude, whatever you're using, whether it's Opus 4.6 or 4.5 or Sonnet or Haiku, it'll respond to you in purple saying, share one moment.
After it returns whatever you want, then you continue in this vein.
And so what I'm trying to get at is there is a pattern here, right?
There's user and then there's model and then there's user and then there's model.
The way that the Claude.md prompt works is basically at the very first message, before you even get to that point, what's hidden from you is the fact that there's actually another prompt.
Okay.
This prompt is injected at the very top of your conversation string before you even send the first message.
And so this Claude.md being sort of the very first thing that the model reads and sort of internalizes is really, really important to help steer the output of the ship.
Now, what is steering the output of the ship?
Well, I often use an analogy here.
Let's say you're somewhere on the East coast of, you know, North America and you're trying to go to, I don't know, let's say the Westmost coast of Africa or something like that.
As you guys know, these intervening distances are really huge.
These are, I don't actually know how long it is, but probably at least 10,000 kilometers or so.
Now, if you're a ship positioned right over here, okay, and this is your port and your goal port is over here.
Let's hypothetically say you have limited ability to steer the ship for whatever reason, the steering wheel or whatever the ship equivalent is, it just doesn't really turn that much.
What that means is if you wanted to make it as close as humanly possible to that X, what you would have to do logically is you'd have to make sure you're very, very accurate, at least when you leave the port.
And the reason why is because if you're not, okay, if you give even a very slight range of possible, I want to say angles that you could go.
Okay, it may not seem like that big of a difference if you go, you know, from this line to this line, at least initially, right?
But over an intervening distance of tens of thousands of kilometers, obviously this goes a very, very long way away from what your goal is.
And so steerability in AI is basically when you try and minimize the number of potential or the width of all of the potential options.
And so what Claude.MD does is it allows you to take the space of like, you know, a really wide angle of ways that the AI could go.
Okay.
And it's like, I don't even know where that we're going to go if we take that topmost path and then compress it down into a much more likely subset of possible options that the AI could go such that, you know, if you were to be even slightly off here, the impact on your final destination, while, you know, you wouldn't make it to your goal.
You'd still make it pretty close.
So I want you to treat your Claude.MD as basically that initial trajectory that you launch all of your Claude sessions, whether in terminal or whether in the GUI tool, like I'm showing up here.
So with that understood, now that we're on the same page about how Claude.MD is injected at the very front of any conversation, you start to realize that there's a tremendous amount of value in making that Claude.MD as high quality as possible.
Okay.
So including a file, capital C-L-A-U-D-E dot M-D in any workspace project directory means that this is now injected at the front of our conversation.
And so you don't talk to this any differently than you would Claude itself.
This is just a file that standardizes it and makes it really easy to build in like conventions for different workspaces.
In such a file, you're going to want to be very concise, and you're also going to want to give it sort of the bounds of what this workspace is for.
I could just as well actually copy this whole thing over, okay, and then paste this directly into my Claude code and then just get rid of my Claude.MD entirely.
But the value in having a Claude.MD is I just don't have to do that every time.
It's initialized very top of that conversation history like we just saw.
And so what's in here, to be honest, is not super important.
I actually had another version of Claude just develop this based off some Twitter posts that I saw that talked all about how to build websites with best practices.
And you guys have access to all this stuff down below.
I obviously have that template folder that you guys could use to get this and anything else.
But suffice to say, this is how, or one of the ways rather, that you can currently design websites using Claude code.
So the three major ways that people are currently using Claude code and other agents to do designs are as follows.
The first is that you give it a pre-existing design and then you give it the ability to screenshot itself over and over and over and over again.
And basically what happens is the first variant that they create that Claude code creates will be like an 80% match.
Then it'll screenshot that, compare it directly to the source image and then list all the differences and then get 90% of the way there.
And then it'll get 95% of the way there.
And it usually can't get 100% of the way there, but it can get like 99% of the way.
The value in this sort of approach is what we're doing is we're basically taking an inspiration website.
And so in our case, we're going to be using it on this site here.
And then we're using that to template out a bunch of like design fundamentals.
So like the size of the text, the colors, the way the buttons look and stuff.
And then what you do is you just change the content of the site with Claude so that it's like whatever site you want it to make.
So in my case, you know, I run this business called LeftClick.
This is my automation agency.
You know, we help people install growth systems into their businesses, typically B2B agencies.
So what I would do is I would basically try and rebuild this site using this design.
And, you know, I could make some minor changes afterwards.
But so long as I start with this nugget, Claude tends to do a really good job afterwards.
The second way to build is you basically just give it a massive voice transcript dump.
For those of you that didn't know, there are now ways for us to basically dump like a larger amount of text using a voice transcript tool.
I'll show you guys what that looks like now.
But if I just hold this FN key, this little widget appears in the bottom of my screen.
Now, this is listening to everything that I say.
And because I can speak a lot faster than I can type, I can actually say a fair amount of pretty short period of time.
Most people type between 50 to maybe 70 words a minute, but we talk closer to 200 words a minute.
That's a two and a half to maybe three X improvement.
And because these models are so intelligent and smart and capable of extracting the meaning from the text, you know, text is all they look at all day long.
What you could do is you could just use a massive voice transcript dump to basically spell out everything that you want on the website.
This isn't going to one shot your website because we don't have a pre-existing design.
But then you can just go back and forth with it.
And then in a fraction of the time of developing a real website, using a voice transcript tool, you can get pretty close.
The third major way people are currently designing is they use components.
Now, for anyone here unsure of what components are, basically there are now services and tools out there like 21st.dev where designers have created specific components on websites.
And there are features on these where you can actually click on it and then click on this button up here, copy prompt.
Okay. And then it will take this entire web page, entire design, you know, this little animation flickering thing, this jump on a call button, the sign up here about whatever.
And then it'll copy all the text needed to have Claude code reproduce that for you.
And so it's really straightforward and simple.
You just make an account of one of these services.
And then let's say you're building a website, you scroll through and you're like, wow, I really like this background paths component, right?
With these cool sweeping things.
I want that on my website.
You just copy the prompt, paste it into Claude code and say, hey, install this thing somewhere up at the top.
Because AI is great at language, you know, you can get pretty close.
So you can do all sorts of things with this.
You could do like cool button borders.
As we see here, you could have like a sign in component over here.
You get a multiple cards.
You know, this stuff is okay.
To be honest, I find it much easier just to go straight to number one, which is just giving it a design and a screenshot loop and just having it work off of something pre-existing.
I don't want you guys to think of this as like you copying a design.
As you'll see, the end result will be quite different from this, but it's just a good way for you to like, get a rough idea of the end design and also not have to worry about things like the sizes of fonts, you know, the, the colors and so on and so forth.
Okay.
So we're basically going to use this as like our inspiration.
And then once we have our inspiration in place, Claude's going to be able to design whatever we want, whether it's an app or a dashboard or whatnot, very, very quickly.
The final thing that I have to talk about before we actually do the designing is the difference between building something and then deploying.
So when you build something, you're typically building it locally.
When you do a tool, an automation, like we're going to do later on in the course or an app or a website, you know, we're running this thing on our local computer.
But if we want other people to be able to access it, then obviously we need to deploy it.
We need to push it onto the internet and the variety of different tools that allow you to do so.
So today I'm just going to show you how to build the stuff.
And then over the course, the next few modules, as we get deeper and deeper into your course, I'll also talk a little bit about tools like Netlify, Roussel, Modal and whatnot.
That allow you to pull to push both your software, the tools that you make, and then even things like websites and full fledged apps to the cloud so that other people can access it on a domain like, you know, Nick's awesome tool.com.
Okay, so without further ado, how would I actually go about this design process?
Well, as mentioned, I had this Claude.MD file set up here, and this is just something that I had Claude basically scrape through Twitter to find me the best practices of all of the different types of website designs out there that people are currently using Claude and other tools to create.
And then I just had to like, write me a little script, basically a little summary.
And this is very squarely this give it a design screenshot loop.
It's just written in like a very particular way.
You do not need to know how the tools work.
You don't need to know how anything works.
You basically just need to know how to like, find a resource out there or use AI to find a resource and then use it to make your own Claude.MD.
With that in mind, what I'm going to do now is I'm actually just going to go on the website that I want.
I'm going to screenshot it.
However, if you guys aren't familiar, you know, if I just screenshot like one section of the site, like this, for instance, on Mac, then I feed it in.
You know, I don't actually have most of the site, right?
I only have that hero header.
OK, in terms of how to actually build this puppy, use command shift I or right click on the page and then type inspect.
This will open up a window that looks something like this.
Once you're done, change the dimensions to full page width on desktop.
That's usually 1920 by 1080.
This is termed the widescreen aspect ratio.
Then just hold command shift P.
I think it's control shift P on Windows.
You'll open up this little command bar.
With this command bar in place, you can then just type in screenshot and then go capture full size screenshot.
It'll actually scroll through the whole site and take an entire screenshot for you.
If I click on this button now, as you guys could see, we now have a screenshot of the entire website, top to bottom.
It's kind of a hack.
Not a lot of people realize that you can do this, but you can.
It's pretty neat.
And once we have this, we just have to do one more thing.
It's pretty big right now.
If you were to send Claude Code, you know, like 20 megabytes or something like that, a file, number one, it would like really massively eat up your token limits.
And then two, I think the API might have like a limit on this.
We just have to make this file significantly smaller.
So I'm just going to open up this resize PNG file here, a page called resize PNG from I love image.com.
You can use whatever the heck you want.
And I'm just going to drag and drop this in.
I don't know.
50% smaller, even like 75% smaller and then click resize images.
This is now going to basically re-map this for us.
You can click download.
What we're looking for is we're looking to get a file that's less than about.
I want to say, I think like four or five megabytes or so.
So it's not perfect.
Okay.
It's a little bit blurry, but it's all right.
I'm just going to go back and resize this one more time so that it's, I don't know, maybe a little bit bigger.
Let's do 50% smaller instead of 75%.
Okay.
Once we're done, we can click download resized images.
This one is about four megabytes or so.
If we open it up, you could see that it's still high quality, but it's much, much smaller than the other file, which is like three or four times.
And now that we're done, we just add this into Claude Code.
So back to our Claude Code instance.
I'm going to go down here to bypass permissions.
Then I just need to go find the file.
So I'm going to click this top right hand corner and I'm just going to see if I can drag this in directly.
So it's going to open this up.
That's okay.
Just zoom in, copy, and then you can actually paste this in directly.
Okay.
So just click that copy button, paste it, and then you actually have the whole file as context.
Okay.
And then we just have to do one more thing.
We're just going to head back to the website.
I'm going to find actual and then scroll down to this little body tag and then right click and press copy styles.
This is going to copy the styles of the site, including the button colors and sort of like the little gradients in the background and so on and so forth.
You can paste that in.
Okay.
And then I'm just going to press enter.
Now that we've uploaded these, keep in mind that despite the fact that this might mean nothing to you or I, keep in mind that there's that extra prompt that's been injected up at the top.
That literally says when the user provides a reference image screenshot and optionally some CSS classes or style notes, you should generate a website.
So that's what it's doing immediately.
It's analyzing the reference image and building this website recreation.
Let me start by creating the actual HTML file.
So this will now walk through its own little to-do list, take screenshots of its created website, compare it with round one, basically do the same thing over and over and over and over again, until it gets to where we want it to go.
And this is really what I'd consider to be the core building philosophy for Claude code.
What you do is you basically give it a high level task, which in our case we did with the Claude.MD.
Then we allow it to do the task and then we allow it to verify or basically judge its results.
I think the reason why a lot of people end up sucking at Claude code or maybe they end up giving it instructions and then not being satisfied with those results is they'll just give it the task and then it'll do the task.
And then their loop is kind of like this, right?
Task, do the task, give it another task, do the task, so on and so on and so forth.
If you don't give Claude code the ability to verify its own results, either visually through a screenshot tool, or if you're building some sort of software through like automated testing mechanisms and so on and so forth, test driven development, then you lose like the vast majority
of the value of AI.
The reality is AI is not going to be perfect the very first time, but the value of AI is not in its ability to one shot everything 100%.
The value of AI is its speed because you can have it get to 80%.
Let's say this is like a, I don't know, a little quality bar or something.
You know, what you can do is you can immediately, you know, it's not just going to be like, this is time step one, two, three.
It's not just immediately going to be at 100%, right?
That's just, that's not what it does.
It's not going to go from here to here in like two seconds, then be done.
What it is going to do though, is it's very quickly going to start here.
Then it'll go here.
Then it'll go here.
It'll go here.
And then eventually after two or three or four time steps, it'll, it'll hit that 100%.
And you know, we think that this is a really long period of time.
Okay.
But in reality, this is like five minutes.
And if you contrast this with how long it would take a human to do that same, you know, approach, you know, humans will probably yet closer to 100% quality on their very first go.
But it's not going to be like a minute or two.
What this is going to be is it's going to be like, I don't know, five hours.
You know, we actually believe it or not, tend to be a lot more precise than these machines that we've built.
We can one shot things to a much greater degree than they can, but their ability to test and then retest and work really, really quickly orders of magnitude times faster than we do is the real value.
And that's something that I don't think enough people talk about.
So just make sure there's always a task, do the task and then verify the results loop somewhere in here and you'll be fine.
Now heading back to our, um, plot code instance, you could see it's now actually completed the first round of its HTML.
Now it's, um, screenshotted it as well.
And then it's basically comparing the screenshot to the work that it's generated.
And with this, it's going to make minor changes.
So as you see, the very first thing it's done is it's replicated to get paid the same day by setting a payment link or the most flexible invoice in the planet with the buttons and so on and so forth.
Okay.
It's also replicated that top section and it's used little placeholders here with these 160 times a hundred little buttons, even with like the right tilt and whatnot, because it doesn't have access to the images.
It then is, uh, you know, entering these little divs, right?
It's even got this cool little post-it note, which is really cool.
And then it even has the reviews.
And so as sort of like rebuilding the design of this website, it's doing a really good job.
And we're only a couple of minutes in what's cool too, is if you check out the thinking tab, you can see that it's gone through.
Iteratively every section of the site.
Okay.
And it's, um, you know, listing what it needs to do next.
So better decorative elements and hero, better floating band, fixing the blue dot positioning, improving the invoice cards with map thumbnails.
I don't know what half of this stuff means, but to be honest for me, it's not super important.
Just because I want it to be a little bit special and then show you the parallel capacity of Claude Code.
What I've done here is I've actually opened up another anti-gravity instance.
And what I'm going to show you guys how to do is actually design multiple of these simultaneously.
Once we built this test, this do test, and then verify loop over and over and over again, which we already have in our cloud.
M D it's actually really easy to spin up multiple prompts and just have like 10 versions of cloud working on things simultaneously.
So just for shits and giggles, why don't we head back over to our little website designer?
It's that giving me a file here called twin gate.
Okay.
And then I'm pasting it all in and then my computer's really humming.
Like, uh, you guys probably can't hear this cause I like to noise cancel most things, but it's making some noise.
And the reason why is because I now have two of these instances running simultaneously, both developing me a website on the left hand side of things.
Just expand this.
Um, we see that it's taken multiple screenshots, the screenshot one screenshot, two screenshot, three, you guys see how it's getting closer and closer and closer to the end result.
Well, now it's doing some final editing.
It's making some features thumbnails better on the right hand side.
It's now going through the initial development of that new index.html.
And so because you can run as many clod instances as you have tokens, basically, um, I can run as many of these website designers simultaneously in however many tabs I want.
And this isn't even the most efficient way to do this.
I'm going to show you guys a much more effective terminal management structure that'll allow you to do like five or 10 or 20 of these simultaneously.
Okay.
And the left hand side, it's now saying it's done.
So I'm going to say open index.html.
That's always just going to be the actual website file.
And if you just tell it to open it, it's going to go through and do so in a tab for you.
Okay.
And here is the demo of the website that we put together.
So, I mean, it's not perfect.
It's not everything that I want, but it's good enough for us to start.
So what I'll do now is I'll go back and I'll have it recreate left click.
Hey, this is looking pretty solid so far.
I'd like you to check out left click dot AI.
That's my personal website.
And what I want you to do is to design, uh, or take the information from left click dot AI and then insert it into this website.
I don't want this to be a clone of left click dot AI, but I want it to be pretty close.
Use the formatting and everything that you've developed so far to help place elements and stuff like that as necessary.
Um, insert images as well and make sure that any elements that, um, are there look good.
Continue doing a screenshot loop if necessary until you have something that looks very high end, very professional and minimalistic, just like you've already developed.
Okay.
So I just fed in a bunch of information.
Now it's going to go through, fetch the content from left click, and then help me design the site.
On the right hand side, we're creating that initial index.html.
Now in this case, I obviously did the two website design simultaneously manually.
Uh, but what you can do is you could actually work this into your website or app design process.
You'd actually have it take in, let's say three different examples of, uh, templates or of design inspirations, whether from godly.website or from, I don't know, dribble or one of these big design aggregators.
And then in the cloud.md, you could say, Hey, actually, we need to develop three versions of this.
Then you can give it some source and then you could actually just like, let it do its little test verification retry loop before giving it, you know, a source website, like in my case left, quick.ai to have it like do some modifications or maybe just doing a big voice dump of what your website is, what it's for the various audiences you serve and stuff.
And then at the end, you could actually have three websites simultaneously that cloud presents to you after five or 10 minutes and says, which one do you like the best?
The options here are virtually unlimited.
The other, uh, website developer so far has made this, which actually looks pretty reasonable.
You could see that there's still some things that it needs to change.
Some of the text looks like it's placed weirdly.
Some of the blog posts and stuff like that.
Obviously the development is mostly hands off at this point.
I'm just monitoring it.
And on the left-hand side, we've now taken four screenshots of this and gotten really, really close to that.
And result, um, it's now building like the left click site itself.
Most of the time, I don't actually care too much about what's in the file explorer.
Um, so that is the third panel on the left-hand side of both of these windows.
So for simplicity, what I do is actually just close it out.
And then I usually have on the right-hand side, some sort of output that AI has generated me.
And then on the left-hand side, I just have my actual little chat window.
I'm just going to zoom out just a tiny bit here.
So we're still all on the same page.
We could see everything.
Uh, and then that way I can now just orchestrate and kind of take a step back and see how things go.
The left click design is also starting to come together.
As you could see, we've taken that initial website from actual as inspiration.
So we have like the same sort of buttons and the nice rounding, nice hover effects on things.
And then obviously we have the font.
Uh, but then now we've actually replaced it with left click content.
So the definitive AI growth partner for fast moving B2B companies, tens of millions of dollars
generated and more saved, proprietary systems, real revenue, no fluff.
So we scroll through here.
You can see it's even inserted like a little a button and click video element.
We all have our case studies down below.
We have some pictures of me and my business partner, although we're kind of cut off at the
middle of the head, so we could probably fix that.
And, uh, yeah, we've even got some testimonials, which is really, really clean.
Let's see what happens if I click this button.
Oh, nice.
It's even gone to our discovery page.
We were actually like having button click functionality and stuff like that in here as
well.
Kind of curious what happens if I click on this.
Okay.
Nothing so far, but maybe I can tell it to do stuff.
We also have an about, and then we have a case studies.
That's really nice.
So yeah, I mean, things are progressing more or less exactly like we wanted them to.
We even have our little logo from here on out.
I'm just making minor changes and, um, you know, going to go back and forth with it until
I get what I want.
So on the left hand side, I'm just going to voice dump in my voice transcription tool.
I can do this like this.
I really like the output.
I think the logo in the top left hand corner is a little too big.
Make that smaller.
The bolding of the hero header font is also quite strong.
See if we could try a Sarah font instead of a sans Sarah font underneath the introducing
left click section.
We have a button player over the picture of myself and Alex Ramose and Sam Evans.
But when I click on this, nothing happens.
Either turn this into a light box or eliminate that little button in the middle.
The rest of these look great.
My and Noah's profile pictures are currently cut off at around the middle of our foreheads.
So move us down and zoom out of the photo slightly so that we're perfectly centered in
frame and everything else here looks great.
Meanwhile, on the right hand side, we see this index.html is now done so we can open
this up.
I'll say open in Chrome.
That's not going to open up the other version of that website for me.
And it's looking like it's pretty clean.
It's pretty matched with what we have.
So because I want to do the same thing that I did with the other source, I'm just going
to scroll back up to where I gave it the instructions to basically copy over left click.
And then I'm just going to paste this in.
And now I have this also customizing the site to my specs.
You don't have to develop in multiple tabs.
This is something that I think you learn how to do the more of these Claude code agents,
frankly, that you're orchestrating.
The benefit to this is obviously you can develop basically however many times faster as
tabs that you have open.
But the downside is you also tend to context switch a fair bit.
The number one thing that you don't want Claude code to do is basically just sit around
waiting for your instructions.
So if you are going to do it this way, just be honest with yourself and ask yourself
whether or not there's always like Claude code operating in the background.
I find if it's not running because it's waiting for you for more than maybe 10 or 20
percent of the time, you probably have too many tabs open.
Personally, I cap out at about three or four.
Depends on how intellectually heavy the things that I'm building are.
And, you know, it's a learned skill.
It's not something you're going to figure out right away.
There's a fair amount of like remembering that you have to do as well.
I've built a couple of things to help me build things faster.
One of them is a little hook.
That's a chime that keeps on going off that you've probably been like, hey, what the
heck is that thing?
That's something that you can do.
And I'll show you guys how to do a little bit later on in the course.
With that knowledge, you can basically set different chimes for different windows.
And when chime one plays, for instance, you know that your top left window is done.
So you can go give it some more instructions, look at the results.
When chime two plays, you know, you can go to the top right window and do some work
there as well.
All this stuff in due time.
Okay.
Now we've implemented all of the changes that I want, including some changes that I
didn't even mention.
So you see here in the background, there's this very slight little vertical line
design that it pulled from my main website, which is really clean.
I like that.
It makes it, makes it quite different.
We also have a serif font instead of a sans serif.
I like that.
Makes me stand out a bit.
As we scroll down, you can see that we've since removed that little play button,
which didn't really make any sense.
And it was looking clean.
We have all of our profile photos.
I like how it kind of inset us a bit.
It looks like my buddy Noah's still quite cut off, which is unfortunate.
So I'm going to have to fix that up, but the rest of this looks really good, which,
uh, you know, I'm a fan of.
Let me just make sure all these buttons work again.
Cool.
That goes directly to our thing with some minor changes.
I think this website's basically ready to go and looking at the other option here.
We've, um, more or less taken the same hero header.
We have the calendar button working.
You have this nice noise background, which I like.
We still have some issues with the photos and them being cut off.
You're going to get stuff like this pretty, pretty often, to be honest with
the ad, but that's okay.
You can also manually readjust them if necessary.
I don't really like how there are two logos, so I'm just going to do the same thing.
Hey, this looks great.
I don't like that there is both an image logo and then a text logo.
Just have the text logo.
We want to text Graham just called left click in the top left hand corner.
The noise background gradient looks a little bit blurry, so remove that.
Only keep it on the social proof section.
Myself and Noah's faces look fine.
Just move Nick's or I have his head down about 15% as it's getting cut off a bit
right now, center of the testimonials and client review section right now.
It's a little bit weirdly set off to the left and then change the 2025
copyright to 2026 that's all.
And that looks a lot cleaner to me.
We have our case studies nice and centered.
Both of our heads are visible, which is really clean.
We have our various services and then down here.
Let me just click this button and make sure it opens that tab.
Nice.
So I mean, you know, I wasn't juggling this and trying to show you guys how to do it.
Realistically, hopefully you guys could see, you could build your own super clean,
high-end sexy website and probably less than five minutes now, at least locally.
Later on in the course, I'm going to show you guys how to take this local website and
then deploy it that will similarly just take a few minutes once you know what you're
doing and the various platforms to use.
So you could take the same approach.
You could use it to build an app.
You could use it to build a dashboard.
You can use it to build more or less whatever you want, whether you are sourcing
websites from a repository like godly.website or dot design or whatever, or you're
doing this maybe a little more manually.
Maybe you're actually going into apps that you really like and then you're
using them as design inspo either way is perfectly fine.
So long as you start with that little nugget, everything else, as you guys see
here, it gets a lot easier and worth noting.
I just designed for desktop today, but if you want it to design for mobile or
whatever, you do the exact same process.
You would just do it with a mobile screenshot.
If you are just designing for a website and make sure that your websites are mobile
and responsive and stuff like that, lest somebody open it up on their phone and
get treated with my giant ass forehead.
You can also do that in the agent really easy.
Just say, Hey, make sure this is nice and mobile optimized.
I'm noticing XYZ images in a weird place.
Okay.
So hopefully you guys have now learned at least a little bit about the way to do a
practical build and practical design with Claude Code, as you see a lot of it's
quite hands off.
It's not like extraordinarily involved.
What you do is you basically steer it.
Like I talked about before you carve out the river and then you just give it a
boat and then it just goes along its way.
So long as there's some sort of test driven development loop, some sort of
screenshot or verification loop, the quality that you can end up with is orders
of magnitude better than not.
And if you guys are ever wondering why you're not getting the results that you
want, just make sure you have some sort of verification loop built in next up.
We're going to learn how to build significantly more complex tools, not just
websites and visually designed things, but also whole backends, whole
architectures and things that you could use either to, I don't know, like launch
your own SaaS product or build really cool internal tooling for yourself, your
own personal life, or for your team.
All right.
Now that we've done a little bit of building with Claude Code, we've put
together what I would consider to be pretty solid websites with just a few
moments of work, let's dive a little bit more into Claude Codes, advanced
functionality, and I won't let you guys know that what I'm about to talk about
here, probably less than 10% of everybody that currently uses Claude Code understands.
So when you unlock what I'm going to be teaching you in this module, you'll know
significantly more about Claude Code for one, and then you'll also be able to
combine each of these cool different features in fantastic ways that I think
you'll quickly see the value of.
So what is the .cloud directory?
Just to be clear here for anybody that doesn't know in programming
convention, first of all, this is a folder.
And in programming convention, if you put a period in front of the folder,
this basically hides the folder from view.
And so if you just open it up in a file explore, you wouldn't actually see.
For instance, you know how like, I don't know, in my case, my computer is called
Nick and then underneath that I might have some, some other folders, maybe I'll
have like a documents or something.
Let's turn this off before that frustrates me.
I might have a documents.
Well, if under Nick, I stored another folder called .hidden.
If I were to open up my file explorer, because it has a period in front of it,
and because that just happens to be the convention of the file
explorer wouldn't show it to me.
So this is sort of like the developer way of, you know, building folders
that don't really muck around and ruin your nice organization.
So in Claude codes case, they have a dot lowercase C Claude directory.
And inside of this Claude directory, there's basically support for like
10 or 15 cool advanced features that once you know, you can augment Claude
code significantly more than sort of vanilla out of the box.
So let's run through all of them together.
This is what like a fully loaded dot Claude folder would look like.
Okay.
And there's actually two levels to this and I'll cover both of them in a moment.
But the one that I want to talk about first is right over here.
So inside of the dot Claude folder, you can add a settings dot Jason, which
is team permissions and hooks.
I'll talk about hooks a little bit later on, but that's how I get my
cool little chime noise at the end of everyone.
You have settings dot local dot Jason.
Anytime you have a dot local inside of a file, this basically keeps it local
on your computer as opposed to push it, pushes it to a online repository.
For those of you that are unaware, a lot of programmers and people that use
Claude code use GitHub to basically store all of their active projects.
Now, because GitHub is a cloud service, there are some instances where you
don't actually want the cloud service to have access to the data inside of your
repo, particularly if it's quite sensitive stuff like, you know, tokens
and, and authentication keys and whatnot.
So they develop this convention where you could just go dot local dot whatever.
In order to kind of override that and then not push it to GitHub.
You have the same pattern here with Claude, where your Claude dot MD lives.
And then Claude dot local dot MD.
This is again, get ignored.
That just means it's not going to go over to GitHub.
Then interestingly, you have an agent's sub folder, you have a skills sub
folder and you have a rules sub folder.
And finally you have a hidden dot MCP dot Jason as well.
You know, I think if you're somebody coming into this without a technical
background, you'd look at this and you'd like, be like, oh my God, this looks
insane, like what the hell's going on settings dot JS.
Oh, and settings dot local dot JS.
So when why is Claude capitalized, what does MD mean?
And I'm going to explain all that stuff to you in due time, but for now, just
know that these are basically the various buttons that Anthropec, the developers
of Claude code have given you that you could press to sort of customize your
own instance and each of these files, you can customize to whatever degree.
You can add whatever the heck you want in there.
Some of these files reference other files.
You know, it's really up to you and Claude, because most people don't
actually develop this stuff on their own.
Actually like kind of co-work with Claude to put together their own settings.
But it's up to you how intense you want to go into personally.
I just have a Claude on MD.
Sometimes I'll have skills and agents and I'll run you through sort of like my
own 80 20 setup later on in the course.
Okay.
So anyway, this dot Claude folder actually lives inside of your Claude
code folder workspace, wherever you're working.
So, I mean, I don't actually have a folder set up yet, but let me do it right now.
And if you use this dot Claude folder, you're basically like unlocking
advanced functionality more so than just having a Claude MD in the root of the folder.
So that's what I'm going to do.
I'm just going to move over my dot Claude to, sorry, I'm going to move over my Claude
MD to dot Claude, and then as you see, there are some additional folders here
that I'm going to put together as well.
Inside of this, I'm going to go agents.
Also going to go skills.
And over here, I'm going to go rules and let's explain what all of these three mean.
The first idea is this idea of breaking up your big Claude MD into different rules.
And so basically what this slash rules folder allows you to do is allows you to
take everything that we've written here.
And then instead of just sticking it all into one file, you can define high level
rules that correspond to different parts of, let's say a build.
So for instance, in this example, there's a rule for code style.
There's a rule for testing.
There's a rule for security.
There's a rule for front end.
There's a rule for, you know, within front end react and then styles as well.
And so, you know, code style might be a very simple kind of two paragraph thing
that just explains how to organize your code.
Security might be a pretty simple few paragraph thing that explains how to,
you know, secure your code basis and whatnot.
Styles could be a list of Tailwind CSS styles or I don't know, whatever, just
like some, some sort of formatting instructions to make websites look a certain way.
And so for instance, if you look at our Claude MD over here on the right hand side,
you can see that we've split it into a variety of sections already.
There's like a workflow section.
There's like a technical default section.
There's like a rule section.
We can actually split these into their own rules files.
And that's what I'm going to have Claude do in a second.
Split Claude.MD into its component rules.
Use the Claude code rule specification if you don't know what that means.
And so what I'm doing is I'm empowering Claude code to basically go through our
current folder for one, then if it doesn't already know what, you know,
rule specs are, it's going to go read up on rule specs.
And then it's basically just going to take this file and then split it into,
it looks like three file rules inside of the rules folder.
So now we have rules split into workflow, technical defaults, and then design rules.
Okay. And as you could see, this is a little bit more compressed than we had earlier.
Basically the title of the file is sort of like that little heading.
Okay. Great.
Anything else we'd need for efficient coding,
you know, it can go through and it can create some additional rules for you.
So now if you think about it, okay. And by the way,
I don't actually recommend just asking Claude, Hey, build me rules for efficient coding.
It's not going to do a very good job.
Usually the best place to find like high level instructions and stuff like that.
That's sort of on the cutting edge.
I would recommend like scrolling through Twitter and then finding Claude code
power users. It's like a real gold mine. The reality is Claude code will actually
like incorporate the most commonly used Claude done MD configurations and stuff
like that into every successive generation. So a lot of the time, you know,
you don't have to include the stuff you had in your Claude and OD from like Opus
four or whatever, because nowadays it just sort of understands that natively.
And so if I, you know,
talk about this example in the context of what we've already done, you know,
over here we had one monolithic Claude done MD file, right?
But imagine that we instead split this into, I don't know,
let's just say three rules. You know, we have the,
workflows and then over here were the design rules
and then the tech defaults. Okay.
Now instead of dumping it in as one big Claude and default,
we actually have a lot more granular control over little things.
And so we can organize this to let's say evolve the workflow without touching the
design roles and so on and so forth. And in general,
this form of segmentation can be useful, especially when you're working with other
people, you can give people access to let's say like the styles,
but then maybe you actually have full control over like the top down workflow,
or as I'm sure you can imagine, you could have a really, really long Claude.md,
right? A lot of people have Claude.md that are, I don't know, like many, many,
many thousands of words, sometimes tens of thousands of words.
So splitting it up in this way just helps keep you organized.
It also helps allow you to see areas that like, you don't really need anymore.
It's one thing if it's a giant file, it's 10,000 freaking words long.
It's another thing if it's like pretty simple and pretty straightforward.
So we can similarly create skills and agents and they're organized in very,
you know, similar ways.
I'm going to talk through some specific agents that I'd recommend having,
and then ways to use the skills folder to basically automate large portions of
most knowledge work later. For now,
I want to talk a little bit about the top half of this image. So the bottom half,
okay, this is stuff that we've already kind of discussed.
This is the .Claude slash folder,
but it turns out there was one folder that existed in even higher level than the
.Claude in your workspace. Okay.
And this is like the global folder.
Now, anytime you see this little squiggle, okay,
in computer programming or networking or in file in your file explorer,
this basically refers to like your home folder. Okay.
And this isn't the home folder of your workspace,
not the specific one that we're working on. This isn't, you know,
if I go back to antigravity, my website design example, copy folder,
what this is referring to is this is referring to like the home on your
computer. And so this might be like the Nicholas folder or something like that
on my computer.
And basically Claude code allows you to define settings that are both local,
which corresponds specifically to the workspace that you're in and also global,
which are basically settings that are shared between all of your workspaces.
And that's where the second sort of category bends into.
And so what we do is in addition to being able to set a Claude dot MD on the
local level, for instance, AKA have one that applies to all workspaces.
If we were to expand this just a little bit,
the way that this thing actually works, if you think about it,
is we have the Claude dot MD that's over here.
And this is your local dot Claude. Okay.
But then we also have high level other Claude dot MD files and rules and stuff
like that. Maybe this is called tech rules. Maybe this is called permissions.
You know, maybe this one's called, I don't know, style guide.
And these come from your global
little squiggly line slash dot Claude.
And the way that this is organized is very similar to the way that the local dot
Claude is organized. It just exists in a different folder.
And it basically supersedes any local dot Claude functionality.
So this is another example of like splitting permissions. For instance,
if you're working on a big team, you know,
maybe you as the director of the team have access to like the global dot Claude
tilde. It's called slash dot Claude folder. And in there,
you put your like global settings.
So these are high level rules at the age and in all workspaces reads and
understands maybe things like, Hey, you know,
don't allow people to delete these files or folders when speaking with, you know,
staff members refer to them as X, Y, and Z, whatever.
And then every individual engineer on the team or every individual team member,
they empower themselves with a local dot Claude folder.
And this is ways that a bunch of companies are currently starting to organize
both their high level, you know, home Claude's or their global Claude's. And then,
you know, the ones that exist per workspace. So to make a long story short,
there's actually three layers of Claude dot MD that merged together.
We've talked about two of them so far, and there's like one more that's even higher level.
But basically the first is your personal global.
And that is at the very top level here.
That's in your home folder slash dot Claude slash Claude dot MD.
Then you have the per project or per workspace folder,
which is dot Claude inside of your current workspace slash Claude dot MD.
And there's also a third option specifically for enterprise.
This is like your managed system level Claude dot MD for enterprise licenses and
stuff like that. 99.9% of you will not have enterprise licenses.
I'm not going to talk about this at all, but rest assured,
it's a very similar concept.
You just define another markdown file that, you know,
sort of exists in that ranking or precedence level.
Now if I open up a repo that we haven't looked at before,
this is my own left click site where I'm working using a strategy called get work
trees. Again, we'll chat about that later. But let's say, you know,
I open up a new file folder and I want to run Claude code net.
And I don't actually have a pre-existing Claude code. And, you know,
I want the model to help me with this.
All I need to do is just open up that file folder, okay.
Open up Claude code and then type slash in it.
We'll get into more slash commands in a moment.
What this does is this basically allows us to analyze the current code
base and then write a Claude dot MD that summarizes what the current code base
does and then give some instructions to, you know, a future version of Claude,
which is really cool.
So what this is doing right now is it's reading through all of the files.
It's summarizing them. It's sort of looking through and, you know, seeing, uh,
what, what stands out in the code base,
trying to look for commonalities and patterns between them.
And then finally it ends up creating a capital Claude dot MD.
And it does this directly in like the workspace route.
So it doesn't do this inside of a dot Claude folder. You have to, you know,
do this sort of organization yourself if you want to go any higher level.
But as you can see here, it just put that together and I can open it up and I
can actually see sort of like the way that it wrote its own Claude dot MD.
So this file provides guidance to Claude code when working with code in this
repository. This is a premium marketing website for LeftClack.
It's an AI automation agency targeting to B2B companies.
Here's how to deploy it to Netlify. Here's the architecture.
Here's the design system. Here's the Netlify config, et cetera.
Why is this valuable? I mean, like it technically has access to all this
information anyway, right? So like, why are we getting it to summarize it all?
Well, we're getting it to summarize it all because one thing we're going to talk
a lot about in this course is context management.
And that basically just means all of the tokens currently in a prompt,
as you've seen, there are multiple levels to this, right?
There's like the global Claude dot MD that's injected.
Then there's the local Claude dot MD that's injected.
There's the enterprise level Claude dot MD that's injected.
We're then going to talk a lot more about the tool calls and various tool
definitions. Those are all injected. And then finally, at the very end of it,
you actually have your own prompt that you're sending,
which is also part of the context. Well, if in addition to that,
you force Claude to read through every single file,
every time that you initialize to know what the hell you're talking about,
obviously you have to add significantly more tokens to any prompt, right?
And by doing so a couple of things happen. One,
the quality of Claude on average will go down because there's a negative
relationship between the length of the prompt and then the quality of Claude's
outputs. That's just sort of the way that it works statistically with these
models. But two, you're also paying way more because now instead of consuming,
you know, let's say 10,000 tokens at a time, you're consuming a hundred thousand,
because this thing had to read through your contact dot HTML.
It had to read your index dot HTML, had to read your message.
I mean, it had to read everything. And so Claude dot MD, if you think about it,
in addition to providing high level instructions and, you know, uh,
and steering of the ship also is a mechanism by which you can significantly
reduce your token usage and then increase the average quality of Claude,
because it'll just know everything, especially when you use a backslash in it,
like I just showed you a moment ago, before actually having to read through the
files. You know, it'll know that index dot HTML uses an inverted light color
scheme. Okay. It'll know that, you know, there's a contact dot HTML,
which is a contact page. It'll know how it's hosted.
It's not going to have to like do a bunch of API calls to various services to
this out. It just already knows all this stuff because that's what this slash
init just did. So if you don't already have a Claude dot MD,
I'd highly recommend going to your folder, generate one.
Once you have it generated,
then you can continue making additions and changes as necessary,
but literally just having a description of the way that the folder works is like,
honestly the, the, the 90% of the battle. So for simplicity,
I've compiled the top recommendations into a quick do and don'ts guide for you.
The first thing to do is just run backslash init first,
anytime you're working in a new folder. The second is,
I just use bullet points and short headings,
try and compress information as much as possible.
Basically write in like a high information density style.
Don't just voice transcript dumped into your Claude dot MD.
If you wanted to write a Claude dot MD, for instance, using AS help,
I might actually voice dump into Claude and then say,
turn this into a very high information density summary of rules and stuff.
But the most important things at the top,
there's anything that like it absolutely shouldn't do like never delete XYZ file
or whatever. Mention it up at the very top.
The first few things that AI learns, it tends to remember.
It's sort of like the middle gap of the prompt.
If I were to show you guys what this actually looks like, basically goes like this.
It remembers a lot of the beginning.
It doesn't really remember much of the middle and then it's more likely to
remember some of the end. So this is called your primacy bias.
Human beings are like this too, which is really interesting.
And then this is called your recency bias, which means, you know,
Claude and us are biased towards remembering things at the very beginning of
a stretch and at the end of the stretch, but more so the beginning,
which is why you put very important guardrails at the top.
Periodically review and prune this. Like treat it like living code.
If you have Claude constantly update the Claude.md,
you will find over time it adds things that aren't really super necessary,
some super precise instructions.
It starts changing sort of the way that it talks to you and stuff.
So I treat it sort of like technical debt and then I reduce it over time.
What not to do is don't dump entire style guides and API docs into it.
This is an unfortunate habit that I've seen a lot of people do where they
basically are like, oh, you know, I want this to be my, I don't know,
let's just say a Panda doc companion. So they go to the Panda doc API,
then they download the entire thing.
And then they try and paste it into the Claude.md ends up being 10,000 tokens.
And then keep in mind, this is initialized every single time you run Claude code,
right? In addition to it taking a little bit longer,
cause now you have that initialization time.
It's also just a pain in the ass and it's,
and it's more costly while reducing Claude's quality as mentioned.
So don't do that instead, like talk to Claude, say, okay,
what specific API endpoints are we going to need?
And then give it the whole API and then just have it like prune it down to just
the specific sections that you need or specific,
maybe high level instructions on how to use this API that maybe is not super
relevant or trivial, I should say.
Claude.md allows you to do what's called an at include. This is very simple to
just, you know, I didn't want to spend too much time on this,
but basically if in your Claude.md, you just say, you know,
at get.md and you have a folder called get.md
somewhere else in your computer.
It'll actually go and it'll like include that into the Claude.md.
As you guys can see that functionality sort of taken care of by rules,
but I just don't add include a bunch of files unless absolutely necessary.
Don't write really vague rules in general, like treat Claude like, you know,
a really intelligent savant style intelligence, but also, you know,
people that are, they tend to be really intelligent and savant take a really
intelligent one specific little slice of the field.
If you give them too much rope, they'll just hang themselves.
So try not to write like really high level, vague aspirational things,
unless absolutely necessary, unless it makes sense. For instance,
don't just say be smart. Don't say make no mistakes.
Claude's not going to understand that. Right?
I keep seeing a meme rolling around Twitter and it's like, Claude,
make me $1 million. Don't make any mistakes. And it's like,
that's just not going to,
that's not going to improve the quality of its output or anything like that.
In general, you want to keep it somewhere between like 200 to maybe 500 lines or
so max.
The recommendation is not to go any longer than 500 lines. Otherwise again,
you're just dumping it a ton of context.
And then don't forget to add rules when Claude keeps making the same mistake.
So like if you're working with a particular library or particular software
platform, or again, a particular API, like Panda doc or whatever,
and they have a very specific way of going about things, you know,
every time you load up a fresh instance of Claude code,
it's going to continuously make that mistake,
which is going to cost you again in tokens,
but then also in context because of quality.
So if you find that it makes a mistake more than two or three times, tell it,
Hey, you know, I want you to add this to your Claude NMD so that this would work
the next time I run it on a fresh instance of Claude.
That's one of my favorite things to tell it. Okay.
So these are just some high level rules. Obviously there are more.
If you want like a really powerful way of, you know,
finding solid Claude code tips and specifically at Claude.MD
stuff, I actually go straight over to Twitter slash X and then I say,
you know, compile the last month of high ROI Claude.MD
writings. What are the best things to include?
Because this technology moves so quickly rather than me, you know,
trying to like tell you guys to always include a certain snippet of text in
your Claude.MD.
Basically I just have it go through the last month of Twitter posts.
After a moment it'll tell you the most useful high ROI insights and patterns.
Grok obviously is X's model. They have access to all Twitter posts.
And there's some extraordinarily intelligent people on here that basically live
inside of Claude code. So I get most of like my advanced tips from them.
And yeah, you know,
there's a lot of instructions and advice here given in just the last month or
so. Okay. Now that we've talked about the Claude.MD,
let's talk about a few additional features that not a lot of people understand
they have access to inside of Claude code.
The first is this concept of auto memory. So basically in addition to the Claude.MD,
there is an additional tiny little file that's injected at the top of every
session.
And you'll find that Anthrobek and the developers of Claude code do a lot of
these injections. It's not just the Claude.MD and it's not just this memory file,
which I'll talk about. They have a lot of tool calls, definitions, lots of stuff.
So the way that memory works basically is if you tell Claude something in one
instance, and you tell it to remember it,
it'll actually write it to this memory file. And then in another instance,
when you pull it up, this is like a global memory file. It'll,
it'll remember you. So if I open up Claude code again and down here, I say,
I don't know, what's my brother's name.
So I try and ask it some, let's say personal information that I want it to find
out for me. It'll say, I don't know your brother's name.
You haven't shared that with me. I say, remember that my brother's name is
George.
Now what it's going to do is it'll save that to its memory file. Okay.
Which already has a few other things like the fact that my dog's name is Yelpers.
You guys think my dog's name is Yelpers?
Then if I go to a new fresh Claude code instance, and then I say,
what's my brother's name? Notice how this time we're not going to have that issue.
It's just going to say George. And the reason why,
if we just go back to this very stereotypical,
prototypical example, which just continues to grow.
In addition to both the enterprise Claude.md,
the global Claude.md and then the local Claude.md,
you also have a file here,
which is separate from all of those called memory.md.
And Claude will inject this at the very top of basically every new session.
So in addition to again, this global section here, and then this local section,
we also have a memory.
And then we have a bunch of other tool call definitions and stuff like that,
which I'll talk a little bit about later in practice.
Memory isn't super valuable or anything like that. I mean, Claude.md does a lot of that,
of course, but you know, it's separate from Claude.md.
You can kind of treat this as Claude's own notes.
It's not really your instruction set. Okay. Next up are agents.
As you see here,
we have this agent sub folder within the .Claude local settings folder.
This can be pretty difficult to understand.
So I'm just going to give you a high level overview now,
and then we're actually going to do a lot more agent development later on in the
course. But let's just say I want an agent called tell
me the time.md. And this is a really simple agent.
I basically just want it to tell me the current time.
I can define the tools that it has access to, the model,
the max number of turns that I can have it autonomously go and fulfill my request.
Whether I want it to have global or local memory,
I can give it a little description, a name, and then also down here,
just like a brief little outline of what it is that I want to do.
And so in this case, hypothetically, I'm just saying this is a time teller.
You know, I basically want my big agent to talk to my smaller agent and then say,
Hey, what's the time? Very simple and straightforward.
So I'm actually going to open up a new session here,
and I'm going to say, what time is it? Use my agent.
And if you haven't already seen the sub agent tool call,
it looks a little bit different from what you guys are probably used to.
Notice how now we're opening up this task called tell me the current time.
And what happened is we see this little in input.
What this is is this is our main agent talking to a sub agent.
And so this main agent basically said, I see that Nick said,
what time is it? And he asked me to use my agent.
Let me check all of my available agents.
And then went through the agents folder,
found that there was an agent called tell me the time.md and then said, Oh,
I see there's an agent here that can tell me the time. Since Nick asked me for that.
This is obviously the one that he wants me to use.
It then creates a task called tell me the current time,
and then sends the new agent a message saying, Hey,
Nick wants to know the current time.
Please determine the current time and report it back. Then at the very end,
it says the current time is 2 23 PM empty.
Anything else the agent wanted you to tell me?
Yes. It greeted you with a howdy partner.
And then it gave me a little cute cowboy emoji.
The reason for that obviously is because down here I said also say howdy partner.
And so you can have agents for a million different things. In general,
one off functions like tell me the time aren't really that valuable because,
you know,
your parent agent can sort of already tell you the time for the most part.
But there are a couple of agents that do make sense.
And so if we split this into parents and then the variety of different ways you
could call this used to be master slave, by the way, which, you know,
had a bunch of issues. They had to change it.
Now it's like kind of like parent agent and then child agent.
But if you think about it, there are a few agents that actually make sense.
The first agent that makes sense is in general,
having some sort of research sub agent.
The reason why is because the way that agents work is they're spawned with their
own context.
And so this agent down here that we just spawned has no no context aside from
just this input. It literally the only text inside of it's, um, you know,
prompt is the user wants to know the current time,
please determine the current time along with, you know,
the high level instructions that we defined and tell me the time. Like that's,
that's literally all that it has. That's its whole Claude done MD, essentially.
Um, and so because of this, because of the separation of context, you know,
if you want to keep the total number of tokens that you use as low as possible in
the parent agent, which is usually the smartest one,
like the one that you're paying the big API token usage and stuff like that for,
uh,
instead of trying to fill in a hundred thousand tokens of research when it goes
on the internet and it looks up trends, then it goes,
checks out Google analytics and then it goes pumps things into, I don't know,
duck, duck, go instead of like filling or polluting all the context of the parent
agent. What you do is you basically just say, Hey, you know,
go research X, Y, Z, and tell me
a summary. And then it will go pollute all of its own context window,
get it super long might use 50 or a hundred thousand tokens,
which is why a lot of people use the, uh,
sonnet model series at the time of this recording for that purpose.
And then the only thing that actually makes it back to the parent is just that
summary. So down here, this could use a hundred thousand tokens, right?
But then like the tokens that it transmits back might only be, I don't know,
like two K or something, which is,
if you think about it at a cost savings amount of 50 times,
we're literally 50 times cheaper than whatever the parent costs would have been.
And then we also get to use, um, you know,
a lot of cheaper sub models and stuff like that, like sonnet,
like Haiku and so on and so forth. So research is really, really good.
And that's one, uh, sub agent that I would almost always create.
I'm actually going to show you guys how to create one later for your code and
then also for other automation purposes.
Another one that I really recommend is basically having like a reviewer agent.
The way that the reviewer agent works is in contrast with the research agent,
you know, it having no context is actually the whole point.
So basically what happens is this parent writes a bunch of code, right? You know,
it's like your index.html or as we're going to see,
it's going to be Python scripts or whatever the heck,
it's just going to do a bunch of code for you.
And then after writing all that code, okay,
its context is now really biased towards the way that it wrote that code.
Basically, you know, if you think about it,
there's like 10,000 tokens and all of those tokens are like, Hey, you know,
I should write the code this way because of whatever reason. Well,
if you want it to write really, really good code,
a lot of the time what you have to do is you actually have to give it to another
version of itself with no context and then just say, Hey, this is,
this is the code knowing absolutely nothing. Do you think this is good code?
And if the answer to that question is yes, then obviously it's a good code.
But if not, okay, what usually happens is when you do this,
when you spawn a new agent and then give it the code, it'll say,
it's kind of weird that you wrote it that way. Why did you write it that way?
And then the reason why is because the initial version of cloud, as mentioned,
was just really biased because it had just done all this thinking and stuff like
that. And so, you know, they do this in, you know,
like big enterprises, stuff like that. Like you do,
what's called a code review where, you know,
a programmer writes some big long function or some cool tool or creates a nice
app.
And then they're so biased about the way to do things because they've just spent
like 10 hours, you know,
hammering a particular method or a particular approach that when they give it to
the code reviewer, okay, another human being, the guy looks at it and he's like,
what the hell is this? Why did you do it this way?
He could have done it way easier with another way or whatever. Or, you know,
Hey, I noticed that your security is kind of off. So in this instance,
what the reviewer sub agent does is it basically takes advantage of the fact
that it has no input and then it's able to look at the code with like a totally
blank face. And so with this, you basically say, you know,
look at the code with zero context or no context and break down the code,
plus improve it.
And then what it'll do is it'll take all of the code. So it might feed in,
you know, like 10,000 lines or something. And then it'll return just the changes
to the parent agent. And then, you know, this might be again,
like 2k tokens or something. And the parent agent will,
will do the changes cause it's usually smarter. And then, you know,
now your code's way higher quality.
Finally, one that a lot of people are using is sort of this middle one here,
which is like QA slash testing. Now this is more of like an advanced programming
thing, but basically in order to determine whether or not a piece of code works
or a tool works or a piece of software is like good, typically,
you can develop a bunch of tests and then you can subject to your tool or
software that you just created to these tests to figure it out. Now,
obviously your parent agent can do this, but, you know,
this is just something that would pollute the context and be tremendously
costly, both in terms of tokens, but also the intelligence of the parent model.
And so typically what people do is they'll break things down into this research
sub agent, a reviewer sub agent, and then also some sort of QA or automated test
sub agent in big enterprise. And that's how they do like automated testing of
their code, automated test driven development, and so on and so forth,
which is similar to what I was doing earlier when we designed those websites,
where, you know, we tell it to do the thing, it goes and it does the thing,
and then it uses some sort of way to verify that it did the thing correctly.
You can kind of think of the QA agent as like a way to facilitate that.
It's just with design,
it's pretty easy because you just fee a screenshot in and then you look at,
you know, the screenshot and if the screenshot's good, then you're good.
With, you know, backend development, obviously you need a way to determine,
hey, is the thing that I said that it should be able to do actually happening.
Last but not least, we have skills,
which were previously referred to as custom slash commands.
Now skills are pretty great skills, basically allow you to automate a vast majority
of, I want to say like the day-to-day knowledge work that you may or may not be
doing, especially when you pair it with tools like Excel or Google sheets or
whatnot. Now I came up with this idea of directive orchestration executions.
It was this framework that I put about probably about like four or five months
ago, just as Claude was figuring out how skills worked and stuff like that.
And they've since created skills,
which I think is actually a much better alternative to my DOE framework.
So I just use skills now, but basically what these things are,
are just like subagents.
These are high level instructions that you can give to the parent agent. Okay.
The one distinction between subagent and skills is in the subagent,
it does it all look like a different agent in the skill.
It's like given to the parent agent and basically it's just a list of
instructions allows it to do something.
So I want to give you guys a brief little example of what that might actually
look like using a skill that I developed called shop Amazon.
So heading back to our folder here, if I go down to skills,
you see that there is now a skill called shop-amazon.md.
Up at the top right hand corner, the name is shop Amazon.
Underneath here is browse and purchase items on amazon.ca via the Chrome dev
tools MCP using the user as defined compare by products in Amazon.
Then there are a bunch of high level instructions about how exactly to use a
various, like some various tools to browse Amazon for me and then find products
that I want to do, including stop, like get purchase approval,
do not skip the step. So, I mean, like I often buy products on Amazon.
And to be honest,
there's just so much junk on Amazon now that I don't want to have to spend every
day hours of my time like rifling through mostly, you know,
like SEO optimized garbage, which doesn't actually mean anything.
So what I did is I put together a skill to do that for me. And at the moment,
I require something to connect my basically in photography,
like a bounce sheet or a reflector with one of my stands.
So what I want to do is just, I'm going to speak into it. I'm going to say, Hey,
I'm shopping for something to connect one of my reflectors to one of my tripod
mounts.
I purchased the reflector a couple of days ago and I didn't realize that I needed,
you know, something separate to kind of clip the two together.
Could you shop Amazon and give me some options that I could use?
So I'm just going to press enter here and then I'm just going to let it go on
its way. We open up the thinking.
What it's going to start with is the user is asking me to help them shop on
Amazon. Then the user wants to find a reflector holder or whatever.
And now what it's going to do is actually an open up a Chrome tab for me using
Chrome dev tools. And it's going to go and it's going to look for it. Okay.
Now it knows that I'm in Canada for instance.
So it's actually looking it up at Amazon.ca up here, scrolling through,
it's going to open things up, take screenshots of various parts of the page.
It's going to read through everything and so on and so forth.
And it'll actually at the end of it, get me a bunch of options,
according to what I wrote in my, you know, shop dash Amazon markdown skill.
And so if you think about it,
like this is something that previously a virtual assistant or something might have
done, right? I mean, this is something that like I would have just given to
somebody and delegate it away. Hey, you know,
I'm setting up a photography studio in X, Y, and Z. Well,
now I can actually just write a skill,
a high level skill that teaches it how to use Amazon.
And then once it goes through Amazon and you know, finds me the products,
then just gives me like a big list of things like this. So what I can do now is I
could say, Hey, you know, I want to buy X, Y, and Z.
And then I can go and actually buy it for me. You know, obviously I recommend,
if you guys are like making purchase decisions with Claude Code,
this isn't really something I'd a hundred percent automate. You know,
maybe I'd have it add all the products to cart. And then I'd say, Hey,
give me the page so I can review it and then purchase it myself.
But you can automate this about as crazily in detailed as you want.
What we've done is we basically made an API out of Amazon and they don't have
one specifically because they don't want everybody to. With cloud skills,
you can do something like that super easily.
The variety of other skills that you can create,
this one's called Upwork Scrape Apply. I have a bunch that do like, you know,
lead scraping for me more generally.
I have skills that automate the process of sending welcome emails to new clients.
I have skills that automate the process of building their deliverables.
And what's really cool is you're not the only person that had,
like you don't actually have to put the whole skill together yourself.
You can just have cloud help you put the skill together for a future instance
of cloud. And in practice, that's usually what I do. I'll say something like, Hey,
I want to build a skill that does X, Y, and Z. Can you help me format it?
Here's like how skills work. Cause sometimes it won't know for whatever reason.
It'll have to go research skill formatting and stuff like that. And then we'll say,
yeah, sure. I could put one together for you.
Then what you do is you take that feed that to a fresh instance of Claude Code
that has no understanding of what the skill is, see how it does.
If it screws up, you just give it feedback and say,
can't modify the skills that you do better next time.
You rinse and repeat and eventually you get an error rating,
which may start off at like, I don't know, let's say like it,
it's only good 70% of the time on your first. Well, after some changes,
now it's good 80% of the time. Then after a couple more changes,
now it's good 90% of the time. And then eventually I want to say,
you can get to like 98 to 99% fidelity and accuracy,
which in any sort of knowledge field nowadays is more than enough.
I'd say most human beings screw up more than one to 2% of the time.
So we'll cover a little bit more about skills and how to create them,
how to take preexisting SOPs and workflows and stuff like that,
and convert them into skills a little bit later on. But for now,
just know that they're there. Okay.
So most everything the year has now been covered. We talked about Claude,
we've talked about the Claude.md, we've talked about the local,
we talked about the agents folder, the skills folder, the rules folder.
We only have a few things left. Like there's MCPs to talk about,
but now's not a good time to, so I'm going to push that off to later.
And then also the settings.json is a good thing to mention,
but since this deals with hooks, I'll also talk about that later.
You're now at the point where you understand, I want to say, you know,
90% of the internal workings of Claude code.
You understand the file structure, the organization,
you understand the highest ROI way to build anything,
whether it is a simple website or something more complex,
like a full stack app or an automation. From here on out,
it's really just learning a little bit more about Claude's various modes.
So plan mode, dangerously skip permissions, you know,
ask before editing and so on and so forth.
And then we can take a listen and we can use it to build something really,
really cool.
What we're going to learn about next are the various permission modes available
to us in Claude code. Now, just so we're all on the same page here,
when I say permission mode,
what I'm referring to is this little button down at the very bottom of the GUI.
And you can toggle through this button pretty straightforwardly and easily.
And as you can see here, when we do, we get four main modes.
The first is ask before edits. The second is edit automatically.
The third is plan mode. And the fourth is bypass permissions.
I should note that you're not actually getting a bypass permissions right out of
the gate here, at least not as of the time of this recording.
So I'll show you guys how to enable that yourselves.
So we're going to run through each of these as well as some extras.
And then at the end of today's module,
we're going to focus significantly more on plan mode.
I'm going to walk you guys through how plan mode works,
why you might want to use it,
and then ultimately how to use plan mode to build something that I've personally
been wanting to build for quite a while.
So we're going to do it interactively together.
So permission modes control how your agents handle permissions.
You also give the current permission mode to any sub agents that you employ,
which is going to be pretty important for later.
Now they tend to inherit the permission context from the main conversation,
but there are a couple of situations in which they can actually override the
mode too. For now,
I just want you to pretend that all we're talking about are our current top
level agents. We're not focused on any sub agents or any additional
functionality, nothing like what we just talked about earlier.
So we have default. Default is standard permission checking with prompts.
You guys remember down here where it says ask before edits,
you guys can think of this as basically the default. Okay.
And so the default setting is before Claude makes any changes to
any files on your computer,
it has to ask you whether or not it's okay to do it.
And I'll show you guys what that looks like right now by saying, you know,
change the title of the project to Nick's happy fun time.
So because I'm in ask before edits mode,
you'll see that before it does any sort of change,
what it's going to do is it's first going to look at the specific file that
defines the title. It's going to pop open on the right hand side,
the exact section of the page that it's considering updating.
So initially it's a profile name dash work log profile name.
In this case was Nick. It defines some really cool, badass variable stuff for me,
but because of my dumb request at now saying title equals Nick's happy fun time
in lowercase, you'll also notice,
I'm just going to have to remove my head here so that we can see this a little
bit better. You'll also notice that down at the bottom, it says, Hey,
should we make this edit to index.astro? That's the file.
And I have three choices. I can either say yes, by clicking or pressing one,
two saying yes, allow all edits this session or three. I could say no.
And finally, I can also say tell Claude what to do instead.
JK please don't do this.
And so because of this, it's going to say no changes made.
And I will not have actually gone through the request. Obviously,
most of the time we don't actually do that. We don't actually make that third,
or rather we don't click that fourth one. As you see, it's also kind of annoying,
but generally speaking, if you guys are working in a code base, that is,
I don't know, really high risk, sort of high reward thing,
where like every change needs to be good, or it's going to screw everything up.
You can use ask before edits.
I should note that very few people are nowadays.
We moved away from ask before edits.
Most people now use either the next setting them to show you,
or they just bypass permissions like me entirely.
The next major setting is accept edits and accept edits.
What we do is we auto accept any edits to files,
but then if you want to create new files, it'll still ask you for it.
And so going back to our little Claude code page here,
we moved from ask before edits to edit automatically. Okay.
We can now edit any preexisting files.
So we can do is we could say, sorry, I actually want you to do this,
update the project to the title.
And because we've selected edit automatically instead of ask before edits,
it'll actually go through and it'll automatically update that for me.
See how there was no little panel on the right hand side.
So this is useful when you want to give the model like carte blanche control over
any preexisting files,
but you don't want it to like have any control or any ability to make new ones.
So I'm just going to say revert the change and keep in mind that now,
because we're in edit automatically, it can do so without actually having to pop.
The next one is don't ask. Now there's no,
don't ask permission prompt explicitly set up here.
So if you want to get to your permissions,
you actually have to go backslash permissions and then continue in a terminal.
This is going to open up a new page for you.
That's going to then pump in Claude with some permissions tab.
And then you're going to get a list of all of the different permissions that you
can have, including rules in this workspace. So as you can see,
we have allow, ask, deny workspace. Okay.
So this is equivalent to our edit all tab.
Deny will always reject requests to use any tools.
Ask will always ask for confirmation before using tools and allow won't ask
before using any. What's cool is you also have the ability to add a new rule.
So permission rules are basically where you give it a,
the name of a tool and then you either allow it to use the tool or you force it
to ask you for permissions before using a tool that obviously takes us to that
logical question. Well, what are tools, Nick? We haven't talked about them.
Well, the variety of different ones that Claude code could use.
There's stuff like the ability to fetch things from the web.
There's stuff like bash,
which is the ability to write like terminal commands and whatnot. And, you know,
the purpose of this course is not to go through every single one of the tools.
Cause to be honest,
they're always changing the tools and like the sorts of tools that we have and
that's not super valuable, but it's just so that, you know,
you can identify and then change on a like file or tool basis,
which things Claude code has access to. So long as you're hyper,
hyper specific about it using in this case, you know, this little tools output.
The next tab is delegate.
Now this is a coordination mode for agent team leads. Basically,
the Claude code now has that feature called the agent teams feature where a
single agent up at the top can delegate a bunch of work to a bunch of sub agents.
And so this is the permission that the agent team lead is given,
which basically allows them to delegate tasks. Although,
it's not allowed to do anything aside from just team management tools.
We'll talk a little bit more about that later. Then we have bypass permissions.
This is what I've been using up until now in basically all instances.
Bypass permissions is great because you can do whatever the heck you want.
I should note that there is obviously a risk here.
There was a case a little while ago where somebody had Claude code running on
bypass permissions. And then I think it was on like a Linux computer or something,
where there's a simple terminal command that you could use to basically delete
everything on your computer. It's like sudo rm-rl or rf or something like that.
I don't remember the exact command. I'm sure Claude would be able to tell you.
And basically because of a misinterpretation of the request and, you know,
it did a bunch of research on its own, whatever,
it eventually thought it had to run this command.
So it ran the command and it basically deleted all of the data on the person's
hard drive. They basically had it bricked and then they needed to take it in to
fix it. I want you to know that these sorts of things are possible, of course,
and I'm not a lawyer, so don't sue the hell out of me if the sense of happening to
you, but it's very unlikely in practice.
This sort of thing occurs, it's a vanishingly small percentage of the time.
And nowadays with agents getting more and more autonomy and other things,
and then more and more skill and more ability to plan their own work,
like we're going to talk about in a moment with plan mode. You know,
most people are shifting towards using bypass permissions.
Bypass permissions also allows Claude to create new files, not just delete them.
That in addition to editing files can present a risk. The main risk,
if we're just being like business minded here, is actually you just like,
you create a bunch of additional files that maybe you don't need. And, you know,
because of that, your workspace can bloat over time.
So it's pragmatic and pertinent to every now and then just ask Claude code to go
through your files and see if there's anything in the workspace that just isn't
required anymore. You know, realistically,
as you guys are going to see when we build this next project,
Claude's going to try a bunch of approaches to do things,
both on the front end and the back end, although the back end,
usually much more often. And in doing so,
it'll accumulate like different libraries that it probably doesn't need.
It'll accumulate different files.
It'll create temporary Jasons and all this fancy stuff. And as a result of that,
if you're not constantly on top of that,
you can have a folder that has like 10,000 files and it's all just temp stuff,
which slows down your computer and bloats Claude code. I've done it before.
So we'll talk a little bit more about context management,
how to effectively do that in one of the next modules.
But I just wanted you guys to know that for now in terms of how to set up bypass
permissions, it's actually non-trivial to do this.
And if it's the very first time that you're setting up Claude code,
you won't have access to that. So head over to the extensions tab,
get into Claude code for VS code.
You're going to want to click this little gear icon and go to settings.
That's going to open up this tab over here.
I'm just going to move it over to the middle so we could see.
You'll notice that one of the first settings is Claude code allowed dangerously
skip permissions.
So it'll recommend this only for sandboxes with no internet access.
Obviously mine has internet access just fine. So, you know,
accept this at your own risk, but if you click this button,
you will now have access to it down below.
There's a few other settings here like Claude code auto-save enable new
conversation shortcuts, disable login prompts, and so on and so forth.
I don't really use or change any of these in practice. Okay.
And then finally you have plan mode,
which is going to make up the bulk of what we're talking about next plan mode is
read only exploration,
which basically means Claude code can research things using web tools.
So you can go on the internet and find things out for you.
It can read through all the preexisting files in your directory.
It can also reason from first principles and it can kind of use its own
intelligence to figure things out.
And then it can basically take all of this and put this into a plan document
before presenting it to you. Now plan mode is awesome.
And I use plan mode all the time and basically anytime I'm doing any sort of
build that's more complicated than a simple design.
The reason why it's so good is because instead of acting,
which in the real world takes a lot of time and energy to both do and then undo
all plan mode does is it just researches all the factors involved in the build
before doing it.
If you work in this like theoretical plan space and not the actual like space
of the, you know, the build and all the libraries and all the code,
you will save many,
many hours of building over the course of just the next few days and probably
tens and hundreds of hours over the course of a lifetime of using this tool.
A minute of planning saves you 10 minutes of building.
It's just super high leverage and I'd recommend you.
So imagine two possible scenarios for me in the first scenario,
you build something with Claude code,
then you test it and then you realize that there's some issue with it.
Maybe you're building a simple web app that, you know,
upon login adds some numbers or credentials to a database.
So you've done this now you've realized that it's wrong.
What that means is because the approach is wrong.
Basically the time that you spent building while not completely wasted,
a big chunk of it is wasted. Okay.
So not only have you spent the 15 minutes to build the thing,
not only you spent the five minutes to test the thing,
you also have to rebuild the thing,
which can take 15 minutes multiplied by however many times you have to
continuously test and retest.
That means that the total amount of time it takes you is 35 minutes plus a fair
number of tokens. Not a lot of people talk about,
but this can obviously eat into costs. That is scenario one.
And this is the build without plan approach.
Okay. Now in scenario two, which is the build with plan,
what you do is you spend your first five minutes,
just planning something super in depth with Claude codes, plan mode,
somewhere during the plan, because we're folk, we're,
we're building a super like a granular line item scope here.
We're looking at all the tools and we're looking at the objects and whatever the
heck, there's like a lot that's going on out of the hood because we're doing
that. Claude code realizes that it won't work halfway through,
and then just recreates a better plan that does it.
The total amount of time it takes for you to like get to the building is just
five minutes plus five minutes, 10 minutes.
And then maybe your actual build time now,
because it's like so much better and faster and stuff like that is only five
minutes or 15. So you think about it,
like not only have we saved 20 minutes on a single build,
and we've also done so with significantly fewer tokens.
What that means is it's much better to like do all of your work here,
basically during the planning of the spec.
And this is true not only from Claude code,
but any sort of programming or really any sort of project development,
as opposed to here, which is like where, you know,
your machines are actually building this thing,
like this fantastic, amazing Lego block based construction.
I'm just going to pretend that like we're building some sort of building or
pyramid here, right? Because, you know,
if you screw this up,
what that means is now you have to knock all these Lego blocks down,
and then you have to rebuild it from scratch all over again.
So better to go off the blueprint or the architecture diagram or whatever,
and make changes there than in the physical world.
The physical world incurs a fair amount of real costs. By the way,
I know we're working in the virtual world here,
but it's the same thing as like planning a construction project, right?
You plan construction projects that you don't run into a situation where you
don't have enough materials on site. And you're like, Oh my God,
I got to fricking stop everything for the day and go find some.
So how do you actually use plan mode in reality? Well,
what I want to do next is I want to use plan mode to build out a pretty
complicated project.
This project is going to basically be a full stack web application.
It's going to have a front end.
It's going to have authentication and like an interface where you can log in.
And it's also going to have a backend and we're going to build it in just a few
minutes.
The specific project that I'd like to build today is basically a proposal
generation platform.
I want to automatically be able to generate proposals,
high quality sales documents that I can then send to prospects through this
web interface. I want to do it all natively.
And I basically want to rebuild the functionality of, I don't know,
like docuSign or like Panda doc.
I want there to be all the bells and whistles on it.
I want there to be like the ability for people to sign, but also to like pay.
I want to have my own little login screen so that I can give it to my clients.
And then maybe my colleagues. And I can obviously also use it myself.
I want to, you know,
have like a couple of templates that I produce based off of it basically end to
end. I want to build a fricking app today.
This is much more complicated than just a simple landing page. Right?
So how am I going to go about doing it? Well,
the first thing I'm going to do is I'm actually just going to build out what
I'd consider to be a pretty straightforward project spec,
which is just a list of things that I want this to be able to do.
And there's a bunch of different formatting methodologies here and like
different ways of doing it. You don't really have to worry too much about that.
All I'm going to do is I'm basically going to dump everything in via voice
transcript to a little text tab.
And then I'm going to feed that into Claude Code and have it actually format
that into a specs document for me.
So I'm going to open up my voice transcription tool and get after it.
My goal today is to build a proposal generation platform.
I want this proposal generation platform to have everything that a common tool
like Panda doc might have in so far that I want it to be able to
generate end to end high quality proposals as okay.
So I just did that. I have a tremendous amount of context.
Now what I'm going to do is I'm actually going to go to a new window and
antigravity, which just closed out of the old one.
I'm then going to open up a new folder. So go open folder.
And here I'm going to say new one. Let's just call this proposal generator app.
Once I've created this, I'm going to dump right in.
Then I'm going to go to Claude Code here.
Let me zoom in so we could see this a little bit better down here.
I'm going to go, um, sorry, not by a past permissions plan mode.
As you can see, I'm pretty eager. And then I'm going to go back here,
copy this and then just dump all this in. It's for a matter of white space.
So bear with me. And what I did here is I just,
I just dumped in more or less everything that I wanted to do in the app.
So I didn't specify things in a technical way.
I just told it what I wanted.
My goal today is to build a proposal generation platform.
I want this proposal generation platform to have almost everything that a common
tool like Panda doc might have, except for the template builder functionalities.
I just want to give you a template and have you do it.
Aside from that, I want to be able to generate end to end high quality
proposals as static pages that I could send the URL to the client with.
And now it's going to ask me a bunch of questions about it.
So what front end framework do you want to use? I don't know, whatever's the best.
So I'm just going to say this one. Sure. For e-signatures,
how legally robust do you need them to be? Um, I don't know what that means.
I'll just click the simplest one for straight payments.
Will proposals have a fixed price or variable amounts you set on proposal?
That's a great question. I'll say variable are using super base for the database too.
I'll say super base for everything. Cool. Submit answers.
So what basically this just did is it crafted a little graphically user
interface for me to ask me some questions about specific ways that it wants to do
the project. Um, and in this way we can go back and forth, which is quite nice.
Okay. Tailwind for utility, CSS, shad, CN UI for polished.
I don't know what the hell that means. Let's just click it.
Can you share the proposal template now? Paste it, link it, or tell me the thought path.
I'll paste it next message. That sounds great.
So what I'm going to do now is I'm going to go find a template of a proposal that
I want it to automatically generate for me. Okay.
So I have my proposal template over here. It's pretty sexy. You know,
I give people some problem areas, some solutions. Um, you know,
I talk about why us, I have a little photo of me, Alex Ramosi and Sam Evans up there.
So it's pretty sexy. What I'm going to do next.
I'm just going to move this into my workspace one-time project.
And over here, I'm just going to rename this to call this proposal template.
That's okay. And then over here, I'll say, great,
it's in proposal template.pdf.
And, um, just because I also want the design to be really cool,
use a simple clean design, sort of like, uh, Apple,
follow the proposal template design in the actual generation of the page for
everything else though, make it kind of Apple-esque. Okay. Next up,
it'll read through my proposal template and then think up what to do next.
And now it is generating a plan for me.
It's figured out the nine page proposal document.
It's designing some detailed implementation thing with all the information,
the user flow and so on and so forth.
What's interesting is it's giving this to a sub agent.
You could see because it's using the task feature,
which is basically coded sub agent language. As you can see,
there's a tremendous amount of information that it's going through in order to
generate this. It's also doing some research,
like looking up things from Panda doc, just because I referenced it. Okay.
And at the end it's now finished the final plan file.
So what I'm going to do is I'm just going to scroll through it and read it for
myself. It's very comprehensive proposal generator platform implementation plan.
We're going to build a Panda doc like proposal generation platform for left
like users will sign in, create proposals via AI and share public URLs with
clients. Clients will view sign canvas signature and pay.
The proposal page will follow the provided PF template design.
Also the app is Apple esque and minimal. Here's the tech stack.
I don't know what most of that stuff means to be honest,
and I'm not going to worry about it. Proposal template sections,
cover your problem areas, your solution. Why us, our team,
what working with us looks like, what your investing contracts,
signature payment, database schema profiles. I don't know again,
what the heck this means. I'm not going to worry about it.
And then over here we have a bunch of routes, API things, false structures,
you know, as somebody that is not a developer by trade,
I'm not going to focus too much on that stuff, but it looks like when people sign in,
they hit log in and those will be a dashboard page. When they create,
they'll click new proposal, which will go to dashboard slash new.
There'll be a few form fields to fill out like brief description and pricing rows.
They'll submit it. That'll call Opus and then we'll generate them.
And then in order to copy, we just copy this URL and send it to the client.
That looks pretty clean to me. I'm sure it's not going to be perfect, but yeah,
why don't we give it a go?
So what I'm going to do is I'm going to so auto accept.
And I know just because I've done some things before with this tool stack,
SuperBase specifically, I'm just going to go through it.
I'm going to set up a SuperBase account while it's running me through all of the
stuff that way I can kind of, you know, double up on the time.
While this does some work for me, I can go and do the, the SuperBase stuff.
So SuperBase is a simple database.
Basically it just handles like the logins and also handles like the generation of
records and stuff. First thing that you would want to do,
if you were doing something similar, is you just log right into SuperBase.
Set up a new account if you don't already have one and then start your project.
I'm doing this for free.
So I just started one called proposal underscore generator,
and then I'll click on it, which will take me to the project.
Somewhere on the left-hand side here, we have API keys.
API keys are basically just what we want to give to this so that it just does
everything for me. So let's see here.
We want to give it all keys.
So I'm just going to go copy API key.
And then also I'm just going to,
looks like it's asking me some questions here because it's now, oh,
it's still in plan mode. So keep in mind,
we want to go to bypass permissions mode now,
because instead of having to ask me every five seconds for things, you know,
I want this to be able to proceed. And then I'm just going to give it some stuff.
I'll say SuperBase, I don't know, secret key.
Just going to give it to it and also give it my SuperBase public key.
Why am I doing all this?
Because I know it's going to need this information in order to move forward.
Now in Stripe, I'm going to go over to one of my accounts and then I'll go test
mode, create sandbox.
What this will do is this will give me like a little sandbox version of Stripe
that I could use with its own API keys and everything like that.
This way I can basically like, you know,
process the payments and stuff like that using this test. So here it is right now.
And then if I want to get my API keys, I have them both over here.
So I'm just going to copy the Publishal key. You know, I said,
I want you to take payments during using Stripe basically,
which is why it's doing this. Let's go public.
And then over here, I'll go private key. Cool.
And so now I basically loaded it up with what I think is everything that it'll
need in order to actually go and like, you know, connect.
So I'm just going to press enter here.
In case you guys didn't know, when you press enter,
what you do is you basically queue up another message.
So when this is done with all of its tasks,
it'll now have access to all of my keys and stuff.
So now that it's done that task,
it's going to create all the files and it's just adding all of the information
and stuff like that.
It looks like we have the SuperBaseAnon key.
I think that might be something else that we need.
So I'm going to have to find that information out.
It'll ask me to do this in a moment. So it's not that big of a deal. This is here.
It just got my API keys. So it's going to update the ENV file.
And then at the end of this, it's probably just going to ask me like, Hey,
can you also include X, Y, and Z? Now I could have, of course,
just asked this thing to start building for me. You know,
I could have just given it all the specs and said, go for it.
But the planning that I did not only improves the probability that it'll be able
to do this on a quote unquote one shot,
but it also improves the token efficiency because it's not going to be exploring
10 different approaches at the time of building instead. You know,
it has like a document it can refer to. And that's kind of interesting,
but human beings sort of do better that way too, right?
Like if they're in a business and then you give them an SOP,
standard operating procedure, or you give them a checklist or something,
or you give them a simple three-step rule, they always have to accommodate.
They're much, much more likely to actually use those rules. So, uh,
yeah,
yeah,
the time that I'm back, this thing is either still working
or it's just wrapping up its completion.
I think right now we're like six or seven minutes in,
but what's really cool is you can parallelize your work.
So obviously this is all about being productive,
but there is also sort of like a time management
component to this as well.
Like after you do a plan and we're building a real big
full stack app here, this is not a trivial enterprise.
After we do that, like we're gonna have to wait
a few minutes.
So, you can just set this aside,
the value that this thing is going to get just watching,
having me just watch it is quite low.
You can actually just set this aside,
let it continue the building and then come back
either when it's done or when you hear that little hook
chime go off, which is personally what I use
to make sure I'm always in the loop.
Anyway, I'm gonna go marinate the salmon.
When I come back, this app should be done.
Okay, so three or four minutes later,
I just got back and I see that it is now good to go.
It's just asking me for a few things.
SuperBase project URL, which I'll find,
my Anthropic API key, I need to run an SQL migration,
give it a Stripe webhook, then ultimately deploy to Netlify.
What I'm gonna do is I'm gonna focus on testing
all this stuff locally, and then I'm gonna give it
access to all this information.
And then after I'm done, I'll do the pushing
and the deploying and I'll run and go see
what that looks like.
Keep in mind, you don't need to have any computer
programming experience to do this.
I mean, I didn't really give it anything
that was programming specific,
I just gave it a bunch of needs.
And while of course it went through and did a bunch
of things that were most definitely programming,
I wasn't really a part of that, which is quite valuable.
So I'm gonna go find this information,
I saw your next public SuperBase URL
and then my Anthropic API key.
Okay, so I see it says, reference using APIs and URLs,
this project ID, so I imagine that's probably that.
I'll say project ID for SuperBase is here,
and then throw up a key, I'll just sign into Cloud
real quick and grab, okay, so then I'm gonna grab this
and then over here, I'm just gonna call it
proposal generator app.
And so I'm gonna give me a key that I could use to copy
and no, you can't steal this from me because I
I will have deleted it right after this.
Nice try folks.
You'd be surprised at how many YouTubers don't,
which is hilarious, like half the YouTube API keys
that you see still work like six months later.
Be careful fellow YouTubers, run the SQL migration is next.
So paste the contents of this thing
into your SuperBase SQL editor.
So I guess I need to do that myself.
So I'm just gonna grab this, copy all this and then what?
SuperBase SQL editor and execute it.
Okay, while I'm doing that, I'm just gonna give it this
and then where do I get that?
SuperBase SQL editor.
Okay, there's one right over here.
That looks like it, no clue what the heck I'm doing.
I'm gonna click run, success, no rows returned, awesome.
I think that's what's supposed to happen.
Anyway, we'll see, it'll tell me if there are any issues.
Stripe webhook, register this in the Stripe dashboard
and put the whatever secret in ENV various.
I don't know what that means
and I honestly don't think I need to do that.
So I'm just gonna ask, okay, let's test this puppy locally.
Okay, so it's giving me the information.
It's also saying that the local host thing is ready to go.
So I'm actually just gonna open this up,
paste this in and see, cool, I got it.
So it says I'm gonna have to confirm my email.
So I don't really like that.
So the first thing I'm gonna do is I'll say, looks good.
If the user email isn't confirmed,
don't give it to them in a red error message
that's kind of unfriendly.
Just tell them to check their email
after their initial signup
because right now there's no notification with that.
And then basically I'm just gonna like work through this
step by step, page by page.
Okay, and the first thing I'm getting
is I check my email inbox.
I'm not seeing an email.
So I'm just going to give it a message telling it,
hey, first of all, let them know
that they need to confirm their email.
Second of all, actually make sure
that the email is being confirmed
because I'm not getting it upon the sign in.
Okay, and then it gave me the ability
to turn off the toggle email.
So I'm just gonna save that.
So we now no longer need to confirm the email.
And I'm gonna go back here.
Okay, cool, and it looks like I'm now into the dashboard.
Bottom left-hand corner, we have what looks to be,
I don't know, some Next.js stuff, I think.
I'm not really sure what this is.
It might just be like some developer stuff.
On the top right-hand corner, it looks like we can sign out.
So let me just try signing out.
Cool, and now in the middle, we can create a new proposal.
Just says proposals up here.
So click create new.
Now there's a bunch of information.
I like this.
So why don't I just go my own information?
I wonder if I just generate proposal if that's gonna work.
Let's do 1,000, 1,500, 2,000.
Okay, and then AI, Powered Sales Pipeline.
I actually like this, so why don't we do that.
The client needs an automated lead generation system
that integrates with their existing CRM.
They currently spend 20 hours a week on manual outreach
and wanna reduce this to under five hours
while increasing qualified leads by 3x.
I know they want to get to 100K a month.
Let's do that.
Okay, now for the money shot, let's generate proposal.
Click on the button, don't know what's going on.
No clue whether this is working.
Generally speaking, when you see a little bar like this
with a little circular thing,
like this is pretty poor in terms of like user experience
because I just don't know if it's working or not.
I'm not really sure.
Be nice if there could be some sort of progress,
some way that I could see the thing actually being generated
or upon clicking this, it'd be nice if I went to a new page.
So I think I'm probably gonna do that.
Hey, I'm not sure if the proposal has been generated.
It's been 10 or 15 seconds right now.
Could we do some additional user feedback
after they click the generate proposal button?
Some sort of status, some sort of updates.
Basically, there just needs to be some way that I know
that the proposal is actually being generated,
not just hanging all day.
Okay, it did end up generating the proposal after a while.
It looks very clean, but still I want you to do this.
Okay, so I'm just gonna feed that in here.
I'm really liking this.
I mean, look at the logo even, that's very sexy.
Using the same font, nice confidential.
Oh, this is so sexy.
Look at that, huh?
Wow, I just built a proposal for this.
What I'm gonna do now is just give it some more feedback.
I don't like how the text immediately
under your problem areas is really constrained width-wise.
You should make that a little longer,
maybe two times as wide.
In each of the sub benefits
underneath 01, 02, 03, 04, it's a little too wide now.
So make that maybe 75% as wide.
Do the same thing with the text under your solution.
Under YS looks great.
I want to have that image of myself,
Alex Formosy and Sam Ovens in there somewhere.
So find a way to include the image
in a high quality manner.
There's some minor spacing problems
with the we've done this before,
we focus on money and we don't treat AI as a fad.
They're not perfectly lined up to the numbers
one, two, three on the left-hand side.
Add some images of myself and Noah.
The what you're investing looks pretty clean.
But in general, there's a bit of a discord
between everything being left aligned
and then the service agreement being in white in the middle.
Find a way to fix that.
Okay, and now there's one more thing I want to do.
I just want to verify this works.
Okay, and now I'm just going to click sign and pay
and we're going to see what happens.
Okay, cool, looks like we're here in the example sandbox.
That's awesome.
I'm just going to pump in some payment information here.
Cool, looks like the payment went through
and then we also have this wonderful payment received button.
You can close this window.
That's awesome.
Okay, great, so let's just adjust that final bit.
Excellent, everything worked great.
On the final page where you do the confetti,
make the confetti last a little bit shorter.
The ones on the left and the right were a little long.
And then change will be in touch shortly to get started.
You'll receive an email with more details
and a link to book a kickoff call.
Actually, screw that.
Let's just give them a direct calendar link
to book a kickoff call.
Why not?
That's way easier and way faster.
Okay, so I'm just going to give it my own calendar.
I'll just give it an example here and then boom,
I'll just have it go off again.
So I mean, this looks really clean so far.
I guess there's one more thing I have to check.
I have to check and see if we can see the proposals listed.
Okay, so yeah, we can.
So can I click on this?
Can we go right back to the page?
Nice.
Now, can I just open this up in some new tab
that's not logged in?
Nice, so the slash P must be slash public.
That's really clean.
So I mean, I like this.
We did this in just a few minutes.
Honestly, very sexy as you guys could see.
I did very little work.
And yeah, I just need to find a way to basically
standardize the spacing and the width.
I don't like how this one over here
is on the left-hand side
and then this stuff stretches all the way up to the right.
But this is just a minor design thing
and we can absolutely significantly upgrade this.
God, we even have the signature here, which looks so cool.
I love how that you can now build your own apps, right?
Like you don't actually have to go
to like a big developer or pay out the ass
for some big platform.
You can just like one-shot an app like this
with good enough Claude Code skills.
Okay, and it's gone through and it's updated the widths
and stuff like that.
That looks pretty clean.
Now I'm just gonna go give it some images
and then it should be good.
We're gonna add them to public slash images apparently.
Nice, looking pretty clean if I do say so myself.
Don't know what the hell I was doing
with cuffing my pants like that,
but what are you gonna do?
Just looking at what it changed.
It made this a little bit wider,
but then it made this much, much smaller.
So I think what I'm gonna do is I'm just gonna enforce
like the same width across the entire page.
That probably makes the most sense.
Why don't we just like constrain it
so it'll be like here?
I don't know, like here or something.
That way it'll be somewhere in the middle.
Just gonna take a screenshot of this.
Hey, this looks good,
but I'm finding it a little too wide at the moment.
I believe we should just constrain it
and do a bunch of padding on the left and the right.
I sent you a screenshot of a quick example.
Now I guess we didn't actually do the screenshot, huh?
Cause I mean, it's good
cause it's like mobile optimized and stuff,
but obviously, you know, on my actual desktop,
there's just so much white space.
Let's just center everything, make it scrollable.
And then I'm just going to, yeah,
I'm not really sure why I couldn't take a screenshot
of those, but whatever.
That looks good to me.
Boom, just fed that in
and we should be pretty good to go, I think.
Holy, that salmon's good.
I am definitely doing that again.
Anyway, I gave it some more time
and it's centered most of this, I wanna say.
Looks pretty clean, all things considered.
You know, we're doing some cutting off of faces and whatnot,
but it's not that bad.
And yeah, honestly, this is very similar
to like the quality of a Panadoc.
I guess the last thing I'm gonna do
is I'm just gonna say, stretch the strategy bit
all the way to the end.
That probably makes the most sense.
Stretch this bit all the way
to the bounding boxes of the container,
i.e. the white box should go all the way.
Okay, here's one more thing that I think
this is a good opportunity to talk about.
A lot of the time, this will tell you
to do things like create a GitHub repo,
push the code, et cetera.
Just ask the agent to do it.
Most of the time, it can actually do what it is
that it's asking you to do.
If it can, you know, let it try
and then it'll tell you, absolutely.
Hey, can you do all this for me?
And then it'll just tell you what parts it can do
and which parts it can't.
Okay, taking a peek here.
It's telling me to go deploy the project.
So go here, add new site, import an existing project.
I can do that, select.
And then we need to build settings.
Should auto-fill, confirm and click deploy.
Proposal generator is available.
That's funny.
This is like the universal domain name, you're right.
Like anybody will be able to access this.
I'll put an A at the end because I think it's funny.
Okay, automatically detected next.
What else?
Confirm, click deploy.
Okay, so go to site settings.
And then we need to add all this information in.
So I'll do that.
Environment variables, import from a .env file.
So I'm just gonna paste this in.
So there's this .env local.
Let me grab that.
Okay, and we just imported all of these.
Nice, oh, that's nice.
Now I need to go set up my Stripe webhook.
So let's just paste that in.
Add a destination.
We need to add this endpoint URL.
So proposal generator.
I don't know exactly what all this stuff means,
but just gonna select all.
And then I guess it's just proposal generator.
Okay, and then no description, I think.
That looks good to me.
Okay, everything is now added.
So go through and then make sure my site's deployed.
I saw some issue with it earlier.
All right, so this is now gonna take whatever this is.
And now that it actually has access to the app,
it should be able to update it for me.
I don't know for sure, to be honest.
We'll figure it out.
Hopefully you guys can tell.
A lot of this stuff is me just saying, hey, fix it.
And if it can't fix it, what the hell do I do?
And then it just tells you what to do,
and then you're good to go.
What's important really is like,
if you think about it, like this software engineering stuff,
this is like almost completely automated.
I mean, I was doing more cooking of my salmon rice bowl
than I was actually, you know,
steering the ship after a certain point.
And that's because we made use of the plan mode so heavily.
But what's important really is like your agency
as a developer and like your ideas and your willingness
and capability to like put together things.
In my case, you know, I do a lot of proposals.
I send out maybe one every couple of days right now.
At our peak, we were sending like four or five out a day.
And so doing all that stuff manually
was obviously very time intensive.
Well, if I could just one shot it
with like a little voice transcript
and then an AI prompt, obviously,
and then generate my own landing page,
like that's really valuable for me as a business.
That's something that AI would not know of right now
and would not really be able to do.
So, you know, allow the AI to be your hands.
You, similar to the way that like, you know,
keys and a keyboard are,
you're the person that's coming up
with the ideas and thinking.
Okay, so I'm not sure if you guys are paying attention
while all of this is occurring,
but did you see this little context tab get filled up?
Because this is at 100% more than once at this point.
Essentially what occurs is this is your total amount
of context available to you
as somebody that's doing a build, right?
Well, when this reaches a certain limit,
when it hits, you know, 99 or 100% or whatever,
what it'll do is it'll take all of the texts
that you've written so far,
and it'll compress it down as tightly as humanly possible.
You know, now let me commit and push.
So Netlify Rebuilds might literally just turn
into Netlify Rebuilding.
It'll save all those tokens,
but in doing so also increase the information density
of your prompt.
And then it'll basically compact it.
That's what the term is.
So that you have more information
in the same amount of tokens.
So the next prompt that you use is both higher quality,
but then also doesn't actually run over the token limit.
The unfortunate reality is models right now
only have token limits of some more
between 200,000 to about a million.
Some of them have 200,000, other ones have a million.
The model I'm currently using is about 200K right now.
And that means that like after 199,909 tokens go in,
like there's only room for one more.
That's just the way that they're built, right?
That's just their infrastructure.
So Claude does a lot of these like automated
context management techniques without really telling you.
And that's core of what we're gonna learn
after this project is done.
Anyway, I went back and forth a couple of times.
And now you can see that we have the app live.
It's live on a public facing URL.
So I'm gonna go in nickywicky at gmail.com
and actually sign in with my previous account.
And now you can see, I actually have access
to that same pipeline, that same page that I had previously.
So I'm gonna give that a click.
Everything is nice and centered right now,
which is exactly what I wanted.
Super clean.
What's cool too is it stretched the strategy setup
and fee all the way to the right-hand side.
And then, you know, I have the ability
to do my signatures and whatnot.
So suffice to say like this, this worked.
This app is now functional.
It's live.
It's, you know, honestly probably better
for my purposes than Pandidak was,
which I was paying out the ass for.
Not that I don't think the company's cool,
but damn is that some expensive API pricing,
I think for what it's doing.
In my case, I'm doing all that now basically for free,
at least Netlify, you know, the deployment solution
that I had available was free.
So aside from the Claude code tokens, you know,
it's one of those things where you spend it once
and then every time I ever generate a proposal
from here, I know, it's sort of fixed.
Now, I mean, we built like an app here, right?
This is a full stack app.
That's what this is.
That's why there's like the login page.
There's stuff on the backend.
There's a database.
There's, you know, the front end and whatnot as well.
But I want you guys to know that like,
despite Claude code and how awesome it is,
I'd be very wary about taking apps
that are fully vibe coded
and then publishing them on the internet.
This is sort of my obligatory safety message
because there are people that are out there
that are using Claude code and similar tools
to try and find security vulnerabilities as well.
And unfortunately, despite how amazing Claude code is
right now, it's not at the point where it like fully,
100% patches everything on the front end and the backend.
So what this means is, okay,
there are a couple little safety precautions
that I recommend you have.
The first is I'd recommend that whatever, you know,
URL that you're putting together or whatnot,
it's not like an obvious or basic URL.
Like for instance, I wouldn't just go proposal generated
on elified.app-router.
I actually have my custom URL
and then I'd make the custom URL something that, you know,
realistically is not like trivial.
It wouldn't be like google.com, right?
Like not left click.ai.
I wouldn't make it short
because there are a bunch of services out there
that are scanning all DNS ranges and also all URLs,
which basically mean that like the shorter
and simpler your thing is, the riskier it is,
the more other human beings will have access to this.
Like there's probably already been, I don't know,
like 30 or 40 people that have accessed my service
despite the fact that I just whipped it up.
That's just how it works, right?
People are always constantly scanning the internet
and sending requests.
The second is I wouldn't charge money for these, okay,
without having a developer go through the authentication,
at least the front end, at least once.
And I say this for liability reasons,
like I don't want you guys to like get a bunch of user data,
like usernames, passwords, email addresses,
payment logs and stuff like that,
and then have that exposed to bad actors on the internet.
It just isn't really worth it right now.
Like if you guys are looking to sell apps with this approach,
you know, just pay some person, you know, a few hundred dollars,
have them look over your app, let's be real,
the software is not the mode anyways.
You can just give it to them, screw the NDA.
And just like have them tell you how to secure your application.
Hell, they can even give Claude Code some tips
or maybe like a prompt that you could use
to do it almost automatically.
But I guess what I'm trying to say is like,
despite how compelling it may be to like make these apps public
and stuff like that, and then charge people for their usage,
I personally wouldn't.
I personally only use apps right now,
internally within my teams or for my clients.
I do not roll these things out and then like try and make money
from them off the wider internet,
when like the app store or whatever.
I've just seen too many horror stories.
We saw Cloudbot a couple of weeks ago,
at least at the time of this recording,
which later turned into Moltbot,
which later turned into OpenCloud.
It rebranded 5 million times
because every fricking version of it
had major security issues.
And then people were getting prompt injected
and hacked and stuff like that.
And I mean, like, you know,
there's a fair amount of reputation that goes with that
as somebody in a business context,
but also you are playing with fire here.
This is like, you know, real human beings, consumer data.
So I don't want to make safety too big a part of my thing.
It's just Uncle Ben time.
With great power comes great responsibility.
And hopefully you guys see here, I mean, this took me,
I don't know, 15, 20 minutes, realistically end to end.
I was obviously making food and whatnot coming back.
I wasn't as efficient as I could have been.
But you are certainly wielding great power right now.
And if you're going to have other people trust you
with their credentials and logins and passwords
and everything like that, you need to make sure that,
you know, you're not using that power willy nilly.
Next up, I want to chat context management.
Now, for those of you guys that don't know,
context management is essentially you handling tokens
in a prompt as effectively as possible.
There are many people out there that overcomplicate
the hell out of this.
So I'm going to do my best not to.
If I open up a new instance of Claude Code over here,
and then I type this backslash and then scroll down,
you'll see that I have access to a bunch
of really cool functions here.
I can compact context, cost, debug, init.
I can do insights.
I have the ability to choose between models, thinking,
account and usage, fast mode.
We're going to talk all about this next,
but for now I want to focus specifically
on one slash command called slash context.
Look at what happens when I click this.
If I scroll up and then zoom in a little bit,
you could see here that at the very top,
cloud tells us essentially what is currently using
its context window.
For those of you guys that don't know,
context window in the domain of AI
just refers to the total amount or total number of tokens
that a specific model can deal with at once.
So if you guys remember earlier where we were doing a build,
I said it was about 200,000 for cloud Opus 4.6.
That's the model that I'm currently using.
There's some models out there like some sonnet series models
that can go up to one or 2 million tokens now,
but the number of tokens in a context window
aren't directly related to the performance of the model.
Context window is sort of separate from that.
So cloud Opus 4.6 has a context window of about 200,000 tokens.
And then you'll see here that so far I've used 26,400,
which means mathematically I'm 13% of the way through.
You might be asking, well, Nick,
how the hell is that possible?
All you've written so far is slash context.
Where are those other 26,398 tokens
coming from realistically?
And that's a great question.
Immediately underneath, you could find out for yourself.
And so what I reckon you guys do right now,
if you've never done this before,
is head over to your own Claude Code instance
without even watching any of this
and just type backslash context
and look at all of the things
that are currently consuming your prompt.
Now I should note that this is stuff
that you're actively billed for.
This is not stuff that's free.
Despite the fact that a lot of the time Anthropic and Cloud,
they'll add a bunch of things to your context
that really telling you,
this is still stuff that at the end of the day
you are paying for.
So if you submit a bunch of one-off requests
to like individual instances of Cloud,
note that there's gonna be your prompt,
which it'll bill you for,
but there's also gonna be always like a flat additional cost
of maybe five, 10, 15,000 tokens
or more depending on how you set it up.
Okay, so going down here under category,
you could see all of the different ways
that our tokens are currently being used
and all of the additional tokens
that we didn't really realize were making use of.
The first is your system prompt.
Now, if you guys remember,
cloud.md takes up a fair amount of your context.
And there's different types of cloud.mds.
You have your global tilde slash dot cloud slash.
That's the one that defines all workspaces,
not just the one that you're currently in.
Then you have the local dot cloud right over here in yellow.
In this case, we've broken them down into individual rule
or component cloud.mds.
Underneath, you also have capital memory.md.
And then, and only then do you actually send a message
basically and have your prompt.
And so earlier on,
you remember how we had like 26,000 tokens or so?
Well, probably, I don't know, 10,000 tokens
or something like that was just taken up
by all these system prompts.
We'll double check in a second
because we can actually see the real number.
And then only a couple of tokens,
in this case two or something,
were actually taken up by our other request.
So that begs the question, where are the other,
I guess, 15,000 or so tokens of the 26,400?
In addition to the system prompt,
which to be clear, this is your cloud.md.
And rules.
You also have system tools,
which is as of the time of this recording,
almost 17,000 tokens.
Now system tools are things like
the model's ability to run bash.
That just means open up a terminal.
It's the model's ability to run web search.
That means to request a webpage,
have that webpage information brought back,
parsed, and then dealt with.
It's the model's ability to do things
like create a plan.
These are all tools and functions
that you don't actually realize that Cloud has access to,
but it does.
And this is what the Claude Code developers,
Boris, Cherny, and all the rest of the team
have basically done.
Before you even get to your own message,
which is all the way down over here,
as we see, we have that cloud.md stuff.
Then we have the tools.
Then we have MCP, which I'll cover in a second.
Then we have that memory.md.
Then we have skills.
And then, and only then, do we actually have our messages.
So there's a lot to go yet.
These tools are constantly changing.
And if you guys want a list of all of them,
you can actually just ask your Cloud model.
So I'm just gonna say,
what tools do you have access to list them all?
And it's gonna go through,
and it's going to enumerate every single one.
So you see here, we have task.
That's what opens up every time we call a sub-agent.
There's task output, which is another tool
where it retrieves the output of the agent.
There's bash, which is how you execute shell commands.
Glob is finding a file by pattern.
Grep is searching file contents.
Read is just how it reads files.
You do need an additional tool for that.
Edit is how it changes things.
Write is how it creates and overwrites new files.
Notebook edit is something specific
for a type of file called a Jupyter Notebook.
A lot of people do like data science
and stuff like that in Claude Code.
And Jupyter Notebooks are a big chunk of that.
There's web-fetch,
which is how it calls various internet sources
and then returns it.
This is web search, which allows it to search
sort of like Google.
There's to-do write.
If you guys have ever wondered
where those little to-do lists come up
when Claude Code is doing stuff,
it's that one right over there.
Ask user question.
If you guys have ever wondered
where those little graphical user interfaces come up
where it says pick one, two, three,
or tell Cloud something, that's where that comes from.
There's enter plan mode, exit plan mode.
There's skill, which is just a meta-function
which more or less orchestrates how you call skills.
Then there's task stop, which is useful
because sometimes Cloud needs to stop
something that's running.
Okay, so basically of all of the context,
we scroll back up here and avoid this MCP tools.
We'll cover that in a second.
Okay.
16,800 tokens are being taken up by all those tools,
basically all of the time.
And there's nothing you can do to fix that
unless you wanna go in and make your own version
of Claude Code or something.
I will say, I think that some of these things
are unnecessary.
I mean, I definitely don't need the Jupyter Notebook calls.
I think there are a few additional features here
that maybe I don't need
or we could probably make them smaller.
But this is something that the Claude Code team
is constantly improving, constantly pruning
and so on and so forth.
Next up, we have the MCP tools.
Now, unlike system tools,
MCP tools are things that you define yourself,
which means every one of these tools
is something that I basically put together.
This is something that I connected to an MCP server
to basically extend the functionality of my Claude Code.
So basically what I'm trying to say is
these right here are default
and these ones right over here, you control.
And so, as a percentage of my total context,
I'm spending 2.8% on customizing my own Cloud instance
and then 8.4% with just the default.
Obviously the default ones are a lot bigger,
but some of these MCP tools can be pretty valuable.
Issues with some MCP tools are,
they're really, really big,
as you guys are gonna see when I screw around
with a couple of crappy libraries.
So you have to be pretty selective about how you choose them.
And that's what this next section is down here
called MCP tools.
So for instance, I downloaded an MCP,
a Model Context Protocol Toolkit
called Chrome DevTools.
This just allows Claude to open my browser.
So what I could do is I could say,
hey, open a Chrome instance and go to nixorayef.com.
If you think about it,
the context that I put together here,
let me change this and say, great work.
Go to leftclick.ai.
If you think about it,
immediately above each of my messages
is obviously all of the tools, right?
And so what these tools are,
is they're basically definitions that say, hello Claude,
you have access to the ability to take a screenshot.
If you wanna take a screenshot,
just call this specific tool
and it'll do the screenshotting for you.
And so this is all above sort of my initial prompt
where I say, great work, go to leftclick.ai.
And so when I say go to leftclick.ai, Claude knows,
okay, like earlier on it said,
if a user asks you to go to a website, call this tool,
it obviously just references the specific thing.
And as you guys could see here, it's navigating,
it's taking screenshots
and it's basically controlling my browser right now,
which is really cool.
So that's an example of a tool
that I think is pretty valuable.
That said, there are a lot of tools
that aren't super valuable.
And unfortunately, MCP tends to consume a fair amount
of your context if you're not careful.
As you see here, there's click, close page,
drag, emulate, evaluate script, fill, fill form,
and so on and so forth.
I'm not gonna cover all these
because there's just so many different MCPs that you could use
and each of them have so many different tools.
Underneath that, you have memory files.
You guys remember earlier when I told you
that there was this big like M-O-M-O-R-Y.M-D,
that memory is super straightforward.
And in our case, that's only 88 tokens,
not that big of a deal,
but it's basically Claude Scratchpad as it works.
Next you have skills.
If you guys remember, we had a Claude skills folder
in another repo.
That Claude skills folder basically in our case,
like, I don't know, browsed Amazon
and found something for us.
In this one, we don't.
So the only thing that's really storing
is just the skills definition,
which in this case is 61 tokens,
expressed as a fraction of the total number of tokens
we have available to us, 200,000.
You could see that that's not even 0.1%.
By the way, as I've communicated
and kept talking with Claude, we've accumulated more tokens.
So you can see how earlier it was at like 24,000.
Well, now we're at 30,600, right?
We've gone up from, I think, 13% to 15%.
So that'll continue happening as we go on.
Next up, of course, you have your messages.
And so in our case, we're consuming 2.6%
of our entire context window right now,
just through messages and just through back and forth.
This is sort of inescapable or unavoidable,
although there are ways to manage your context
a lot more efficiently.
A couple of ways are speak in high information density
ways wherever possible.
Obviously, voice transcript tools are kind of against that
because they take into account all of your ums and ahs
and whatnot.
But if you want it to be really, really efficient,
what you would do is you would take your voice transcript,
pump it into a cheaper model,
one that doesn't cost you as much money
that's in a separate tab,
have that summarize it into a very tight request,
and then actually send that to the initial Claude agent.
And that's a strategy that I've used
to manage really small context windows in the past.
Obligatory, this is where the conversation
with Claude actually occurs.
I should note that, I don't know if you guys remember,
but sometimes you can ask Claude stuff
and then a little thinking tab will pop up.
Well, that thinking tab isn't actually included
in the messages.
You are still billed for this separately,
but basically what happens is at the time
that you make a request
and at the time that the thinking occurs,
it sticks all that onto the big message chain
and then it uses that to figure out the next thing.
So it uses basically this thinking area,
it's almost a scratch pad to figure out more.
And then what it does is it collapses it, disappears it,
and then it just gives you the answer.
And then it pretends as if the reasoning
or thinking little section didn't even exist.
So don't worry about thinking here,
assuming you have extended thinking on,
that doesn't really get included,
although of course you are still paying for it.
And then finally, the bulk of our context is free space,
67.7%, which is good for us.
Not really sure why they include that here, but they do.
The last thing that you guys need to understand
is this idea of an auto compact buffer.
Now an auto compact buffer is basically
just a certain amount of space
that Claude's developers always leave available.
And then basically what happens is when you hit that buffer,
aka when there's only 33,000 tokens left,
it'll automatically compact
all of the previous conversation history.
Now this is done automatically,
but you can also do this manually by going slash compact.
What happens when you go slash compact
is it basically takes all of our conversation history here.
It'll take this, it'll take that, it'll take all that.
And then it'll just squash it down
into a very high information density summary.
And so what I'm gonna do is immediately after it compacts,
I'm actually gonna ask it to tell me what it just compacted.
Basically, hey, tell me what is currently available
in your context.
Okay, and as you can see here,
it says this session is being continued
from a previous conversation that ran out of context.
The summary below covers the earlier portion
of the conversation.
First, there's an analysis tab
where it chronologically analyzes your conversation.
First message user ran this, then user asked this,
then user asked this, then user asked this,
user asked this, user asked this,
and so on and so forth.
And so if you compare all of this to all of the messages
and all of the tool calls and everything like that
we did above, this will be fewer tokens, right?
Significantly so, probably like three or four X.
And so in this way, gradual and progressive compaction
of a conversation maximizes the information density.
And then Claude's really good
at like not leaving important things out.
So you tend to have most of the information
that you really want or really need in this context.
They've started also recently doing something
called auto-compaction, which is where this compaction
is occurring constantly in the background for you,
AKA your oldest messages are just like compacted
into higher information density summaries.
And then that's constantly sort of like a tail
behind your current conversation.
That's pretty cool because if you think about it,
us human beings are just not very good
at remaining really concise and being very precise
and constantly updating that context improves the quality
of subsequent outputs, as well as bills you less,
which is kind of interesting because Anthropexol
business model right now is monetizing Claude and Claude
and Claude code.
So the fact that they're doing this sort of runs contrary
to their interests, which is one of the reasons
why I like them as a company.
They're obviously motivated by the quality
of their product more necessarily
than their revenue and whatnot.
So Claude's website here is really helpful.
They have actually a whole section dedicated
to reducing token usage and minimizing the amount
of what's called context rot that accumulates
in a conversation.
I'm just gonna run through them with you guys.
And I want you to know this is constantly being updated.
So the time that you look at it might be a little bit
different from the time that I'm looking at it.
Again, if you guys want like up to date tips,
I recommend checking out Twitter, x.com, talking to Grok
and just saying, summarize the best strategies
to reduce token usage that users have been talking about
in the last month or so.
So you have strategies like RAG,
retrieval augmented generation,
you have strategies like continuously
and consistently compressing the Claude.md.
You have strategies like telling Claude to write
as concisely as possible, but then turning on extended
thinking, which is a feature I'll run you guys through later,
which basically means you blow up the reasoning tokens,
but then the actual token spill ends up being very low
and so on and so forth.
So the number one recommendation that they have
is to manage your contacts proactively by using slash cost.
This helps you check your current token usage.
You can also configure a status line
to display continuously.
In order to configure a status line in Claude code,
you just go slash status line.
You'll notice that you can't currently do this
inside of the GUI version.
So what you have to do instead is you have to open Claude
in a terminal here because, you know,
graphical user interfaces don't have a status line.
A status line is basically this little piece of text
that occurs before.
And then you just go slash status, sorry,
slash status line here.
It'll ask you what you wanna put in your status line.
And so I'm basically just gonna ask it to include
a little like loading bar with the total number
of tokens that I've used.
Update my status line so it includes a little loading bar
that is how many tokens that I've used
out of my total context.
So as you could see, it converted that into another mini
prompt using a status line setup agent,
and then it's gonna do this kind of cool little
status effect.
So I'm actually gonna get to see it down here.
I'll show you guys what that looks like in a sec.
Okay, and as we could see here,
we now have that little bar.
So 13% of my tokens are used up.
That's kind of neat.
We also see the current model.
And then, you know, the branch that we're on
if you're into programming with repositories
and like get workflows and stuff like that.
This to me isn't like super valuable to be honest,
if I'm being frank, I just thought it was kind of cool.
So just another reason why doing all of this in the terminal
gives you significantly more latitude.
You can't really just like add a status line
to the GUI version, at least not now,
but this one's very hackable.
Another thing you can do is you can add custom
compaction instructions.
So you can actually say slash compact
and then give it a prompt telling it what to prioritize.
You could do this every now and then,
which is obviously quite valuable.
You can use slash clear to start fresh
when switching to something that is unrelated.
So what I mean by this is if I just delete
this little terminal instance down here,
just go back slash clear,
what it'll do is it'll clear the entire conversation
so you have no context anymore.
So now there's no previous context.
If I go back to slash context,
you can see that scrolling up to messages,
we have 152 tokens, which is basically everything
that we've done here so far.
Aside from that, you can use instructions
inside of the Clawed-down MD to basically try
and minimize the total number of tokens generated,
as I mentioned.
So you could say something like,
hey, write as succinctly as possible.
You can reason all that you want
because that isn't added to the context,
but when you actually give me something,
just give me the bare bones information.
If I need more, I'll actually ask you.
Choosing the right model is really big.
So if you're using a really simple sub agent or something,
we'll talk about how to develop those later on.
I recommend using smaller models like Sonnet.
These smaller models are typically less intelligent,
but they have much larger context windows
and then you'll build less.
So that allows you to like do all the heavy lifting
inside of the sub agent that's cheaper,
and then they just return you those results,
which is great.
As you see here, the Anthropic team specifies
to reduce the MCP server overhead.
And that's because, as I mentioned to you guys,
some MCP servers just suck.
They just have a bajillion tools.
You'll download one and 20% of your token usage
will be gone immediately.
That's obviously quite costly,
and then it makes Claude much dumber.
So, you know, there are ways to reduce MCP server overhead.
They have what's called
advanced and automatic tool search now.
When MCP tool descriptions exceed 10% of your context window,
they won't actually load all of them.
They'll just try and search for them before.
So meaning you'll say, hey, you know,
can you open up a new page in Chrome DevTools or something?
It won't actually have access to all that immediately.
What it'll do is it'll search first a list of tools
using Gratper or something like that,
which is its own built-in search tool.
And then it'll find one that says open the Chrome DevTools
and then it'll load it.
That helps you avoid massive MCP server overheads
and then obviously wasting a lot of tokens.
Some other tips are to move instructions
from Claude MD to skills.
So remember how earlier I said your Claude MD
should be like 200 to like four or 500 tokens,
lines maximum.
Some people make it even longer, but you shouldn't.
Instead, what you can do is you can break those down
into specific rules.
And then any rules that are more tasks than rules,
you can actually just turn into skills.
So skills will load on demand,
meaning that only when you specifically invoke them
will they be added to your context,
which is quite helpful.
You can also adjust extended thinking.
We haven't chatted too much about extended thinking,
but if you go back to Claude here,
if you go to slash model,
you have the ability to switch which model you're using.
And then additionally, if you go over here,
there's also a thinking tab,
which allows you to turn on and off that little reasoning
or thinking window.
As I mentioned, thinking is pretty valuable
because it avoids you wasting tons of tokens
in the conversation chain itself.
It offloads it to a little thinking tab.
And what you can do is you can actually modify
the effort level using slash model.
You can disable thinking completely,
or you can turn the number of tokens
that you give it to like maximum think from,
I don't know, 8,000 to like 32,000 or more.
Now agent teams is another feature of Claude code,
which I'm looking forward to covering with you guys,
but currently it costs a lot,
about seven times more tokens than standard sessions,
especially when teammates run in plan mode,
because every teammate maintains its own context window.
So they actually kind of recommend against it
if minimizing token usage is the number one thing
that you wanna do.
And then finally, writing specific prompts
is probably the highest ROI tip that I could give you here.
Instead of improve this code base,
you saying something specific,
hey, fix this one feature that I found in this file
is a lot more precise.
And as a result, despite the fact that it'll,
it takes a little bit more thinking on your end,
a little bit more of your extended thinking,
Claude's token usage ends up being significantly decreased.
Finally, even Anthropic says that planning
for complex tasks is the way to go
because this significantly reduces
the total number of tokens you use
when you're actually building solutions.
Usually API calls and calling servers
and requesting web pages and stuff,
these load a ton of tokens in the context.
So avoiding doing research entirely is pretty valuable.
Once you're at the building stage,
just front load the research with plan
and worry about it later.
Now it's time to chat skills,
which in my opinion is probably one
of the most economically valuable ways
that you can use Claude code.
This is a Claude code in aggregate tutorial, obviously.
So I don't just wanna talk about skills.
If you guys wanna know more about how I personally use skills
and things like skills,
I do also have another course that talks all about
what I call agentic workflows,
which are analogous to skills.
But for now, anybody that's not acquainted with this,
I just wanna run a quick demo.
So if we open up this .Claude folder
in the top left-hand side,
you can see that we also have a nested skills folder.
And I have a bunch of different skills here.
I have skills that allow me to classify leads,
create proposals automatically,
not dissimilar to the proposal generator app
that we did before.
I find outliers in my niche,
update and auto-reply to emails,
edit my YouTube videos for me,
onboard new clients to my agency,
apply to Upwork jobs and so on and so forth,
monitor and then classify my school posts.
I mean, if you think about it,
what this is, is this is a collection of all the things
that I usually do in a daily basis,
like for my own intellectually valuable knowledge work,
the stuff that I basically get paid for.
And then what I've done is I've just turned them
into checklists,
and then I've just given these checklists over to Claude.
So let's pretend that I wanna do one of these tasks today.
In my case, I want to scrape some leads.
So what I've done is I've created a skill up here
called scrape leads that scrapes
and verifies business leads using a service.
Then it classifies with a large language model,
enriches the emails and saves it to a Google Sheet.
Use when the user asks to find leads,
scrape businesses, generate prospect lists,
or build lead databases for any industry or location.
I then have a goal up top,
which is to scrape leads using a particular source.
I have a bunch of inputs.
I even have some scripts that I could use to run these.
And then I have a process, and this is my checklist.
Start with a test scrape, then do verification,
then do a full scrape, then do LLM classification,
upload to a Google Sheet, enrich missing emails,
and so on and so on and so forth.
Okay, so as you see here, big, big deal.
This is a fair amount of time and energy
that I used to take to do these lead scraping things.
As part of my work is both for my dental company
and then for LeftClick, on behalf of my clients,
lead scraping is like a major chunk
of what makes a successful cold email campaign.
And I just had to do it myself every time.
It took like an hour or two.
Well, what I can do now is I can just turn
all of my own knowledge into a skill.
Okay, I can define it in Markdown format here,
and I can write it with Claude,
and then I can just say, scrape me 1K dentists,
or 1,000 dentists across the United States.
Now, when I press this button, what's happening now
is it's successfully loading the skill.
It's starting with a test scrape of 25 dentists
to verify my quality.
It already automatically finds the different filters
I wanna use and so on and so forth.
And then it's gonna dump these into a little folder for me.
What it'll do after, according to my skill spec,
is it's going to read through each of these 25 leads,
sometimes do a little bit of background research to say,
hey, are these the sorts of leads that I'm actually,
Nick is probably actually interested in?
And then if so, then it proceeds
with a full parallel scrape of 1,000 simultaneously,
and that occurs quite quickly.
So in this case, it started four of these scrapers
and it's just parallelizing these,
so I'm gonna get 250 from each.
To be clear, previously, this probably would have taken me
15 or 20 minutes to set up the filters, to set everything,
kind of configure that initial search, right?
And then if I wanted to do that search at 25,
I would have had to manually verify them myself,
which took me another 10 or 15 minutes.
After that, I would have started the actual scraper,
then I would have had to upload them into a Google Sheet,
I would have had to cross-reference the leads
to make sure they're good,
I would have had to run some additional AI-based flows,
and it just would have been a big pain in my ass
to make a long story short.
Now, A is capable of doing this for me
in just a couple of minutes.
And I'm running this in terminal because I have access
to what's called fast mode right now.
Essentially, Anthropec's new Opus 4.6 model
has launched with the ability to run two and a half times
faster for approximately three times the price,
so I'm happy to pay a little bit more money
if it means that I can do all of the knowledge work
that I need to do a little bit faster.
As you see here on the right-hand side,
it's now finding a bunch of my leads for me,
it's compiling them into a list,
250 leads done from that search,
250 leads done from that search,
250 leads done from that search,
and we just have one more to go.
Now, what's really cool about skills is
it doesn't need to be right every single time,
it's not like a program,
it's not like I put something together
and then the second that it makes a mistake, it's done.
As you see here, it scraped about 1,000 leads in 87 seconds
and now it's uploading to Google Sheets.
And somewhere along the line, there was an issue.
And the issue was, it turns out I can't use spaces
and stuff like that in the file.
So what it did is it realized that it made a problem,
and then it uploaded it to Google Sheets
with the proposed solution, it went through
and it read through a little bit of the API documentation
and stuff like that to do that.
This is stuff that I previously would have had to do
and that try and retry loop just takes forever.
On top of that, what it does is it goes
and enriches the emails for me.
And then what I end up with is I end up with a list
that looks something like this.
So I just bold this and then I make this a little bit bigger.
I've since hidden the email columns here
just because I don't wanna show too much information.
We have clinic phone numbers and stuff like that,
company phone numbers and addresses.
But as you can see here, we have tons of information
about dentists that are across the United States.
Looks like a big chunk of them are in Philadelphia,
New York, Moorstown, Boston, we have cities,
we have everything that we need.
And so what I'd do with this now is I would take this,
then I would send it into a tool like Instantly,
which is my cold email platform
and then I would immediately start sending.
And as I mentioned, this takes a pre-existing process
that would have taken me at least half an hour,
probably more, and it turns into one
that I literally did in 87 seconds.
So as you can see,
skills can be extremely economically valuable.
The question is, how do you actually go about creating them
and creating them in a way that I think is reproducible
and efficient and so on and so forth.
Well, the first thing is you need to know how script
or rather skill structure works.
If I just zoom in on this to make it a lot easier,
you could see that our scrape leads skill
is broken up into a few components.
First, we have the folder itself, scrape-leads.
Then we have another folder inside called scripts.
This runs the program aspect of the skill.
And then finally, we have the actual skill.md in Markdown.
So I want you to treat what we're seeing here
in the skill.md as basically like the orchestrator
of this whole affair.
So the skill.md is like the checklist or orchestrator.
You know, in an orchestra,
the orchestrator is the person with the little,
I don't know, those sticks.
My sister does some of that actually,
which is funny, I don't even know what the hell they're called.
But you know, it's where you kind of wave them around
and do all that stuff.
And then what happens is, you know,
the orchestrator is not the person making,
you know, the conductor, I should say,
is not the person that's making the music.
What they're doing is they are orchestrating
the production of music from a variety of other sources.
Inside of scripts, we have, you know,
the actual musicians themselves, violinists,
you know, the cellists, we have the pianists,
and so on and so on and so forth.
And so basically what occurs is
we give it a big checklist of tasks in the skill.md.
We give it a bunch of reference information
and everything that it needs.
And we treat it just like we treat a junior employee.
We say, okay, here's the checklist, go out and do it.
And then where the orchestration kind of comes in
is if there's an issue with the step-by-step execution
of different subtasks,
some of which are going to be scripts and stuff like that,
then Claude gets to use its own native intelligence
to fix it in real time.
Not only do they fix it, but then it also goes in
and it updates the skill so that if there's another issue
in the future, or if another instance of Claude
tries running this, it doesn't run into the same problem.
So as you can see, they're very, very valuable.
They're more or less exactly the same way
that like a person would go and do a task.
Now inside of my scripts folder here,
I have, as you can see, a bunch of different
actual Python scripts that have been developed
for this purpose.
Do I know anything that goes on in here?
No, I haven't even looked at this code.
It's probably the first time that I'm ever opening up
this file.
What I did is I told Claude that I wanted it to go
and do things in my checklist and then go create scripts
that would do them all for me.
It's much better to do this than just tell Claude
to do it from fresh and from scratch every time.
Because obviously if it's the same thing
that you need to do every time,
you should turn it into like a defined program, right?
Because then it's always gonna execute similarly.
That way Claude is not actually doing
the executions himself.
What it's doing is it's just using the scripts here,
just like it uses tools.
You know how it has access to bash and web search
and stuff like that?
This is the same idea.
It's just we're doing it encapsulated in a skill.
Okay, so it takes this information.
It goes through the skill.
It says, okay, step one is test scrape.
So I need to run the scrape appify with this query,
max items 25, whatever the heck that means.
Then it goes, it executes this.
Once it's done, it checks the result.
If that's the case, then it goes back
and then it runs the same scraper
except with different parameters.
Assuming that that's good,
then it uses this classify leads LLM script afterwards
to tabulate that information.
Assuming that that's good,
it goes into what looks like update sheet
to like create a Google sheet and then send it.
Assuming that that's good,
it then goes enriches the missing emails
and so on and so forth.
And there's different paths here based off of
how many people we wanna scrape.
I have a few other skills that I use pretty often as well.
This one's called literature research.
And so, if I'm trying to perform research on a task,
I will actually say, go perform a lit review
on the recommended daily dose of, let's say vitamin D
and IUD for males in their early thirties.
What this will do, okay,
in addition to reading the CLAW.MD
to get context about this whole thing,
is it'll go through and it'll read
this literature research skill.
If I open this up so that we can all see,
the first thing it's gonna do is it's gonna query
like this database, which I'm suggesting that it queries.
So this database, I think, was called PubMed.
After that, it's going to analyze
using this little deep review script.
And you'll notice that if I make this big again,
I made some mistakes here, right?
For whatever reason,
the first query did not actually work fine,
but it ended up redoing it over and over and over again
until it figured it out.
And so this is the orchestration aspect that I'm talking about.
You can give it a checklist,
but obviously not everything goes right perfectly.
Because not everything goes right perfectly,
you need to give it some flexibility
in order to do your tasks.
And that's what it's doing right now, right?
It's gone through and it's gone and created
a bunch of literature review-based information for me.
Why would I use this versus, let's just say,
telling CLAW to go find that information?
Because I've already just put in the infrastructure
to query specific databases that I really like.
I've taught it how to run parallel queries
so I can do this research in 10th of the time.
I've taught it to use models
that might be a little bit less capable,
but might have much longer context windows
and so on and so forth.
And so this enables you to find a workflow
that works really, really well,
and then just consolidate it
and then do it the same every time.
This is why I no longer hire.
I mean, my businesses collectively
still make over $300-something thousand per month right now
in profit.
That's a lot of money.
I don't have staff members to do these things for me anymore.
Anytime I want anything done,
I'll just tell CLAW to do it with one of these skills.
Because to be honest, it's the exact same thing anyway.
I would have just hired a contractor
to do this sort of literature research.
I would have hired a contractor to do my lead scraping.
Why do I have to wait around a whole day or two for them now
if I could just execute a skill to go do the thing,
retrieve me the results, and then, I don't know,
maybe feed it into another skill in 100th of the time
for like 100th of the cost.
Okay, so while all of this is occurring in this tab
and I'm doing that research,
why don't I show you guys
how to actually create a skill in practice.
To make a skill, it's really straightforward.
You basically just give it like a bullet point list
of things that you want it to do.
So I'm going to say today we're creating a skill
and why don't I just use my voice transcript tool?
That's way easier.
This skill will design websites in a format
that I really like using a template that I really like.
I want the websites designed very similarly every time
because I'm going to use them to pitch people.
In short, what I'm going to give you
is I'm going to give you a bunch of information
about a prospect and then I want you to design a website
using a specific template.
The template I'm going to supply you is this one.
And then what I'm going to do is,
you know how earlier we went through godly.website
and then we found a template that we really liked?
Well, I'm just going to scroll through
and I'm going to find a template that I really like.
So scrolling through, I don't know,
I just want this to be a simple website
that I could use for, let's just do like,
I don't know, dentists hypothetically right now.
So I'm going to go over here
and then I like this build an Amsterdam one.
Okay, and then what I'm going to do is I'm just going to,
I think that's it honestly,
I think I'm just going to screenshot this
and they'll just make one pager for Claude.
Just going to screenshot it.
Okay, and then I'm going to go back to my anti-gravity
and then paste it.
I want you to use screenshot functionality
to mirror the style of the website.
I'm also going to paste in some of the HTML
so you can use that to create a style guide, et cetera.
You'll receive as input, like a Google sheet
with information about a prospect
and then you just create a website that matches.
Find web images using publicly available sources,
make sure it's really pretty
and yeah, follow the template as closely as possible.
Then I'm going to go on the website.
I'm going to, let's just make it really wide
because sometimes websites are different.
And then what I'm going to do
is I think I'm just going to copy all of this.
It's really, really long, right?
I'm just going to paste it in.
So that's going to be huge.
It's going to be a lot of stuff to paste, 474 lines.
And then, hmm, anything else that we need to do?
I don't think so.
I guess I just need to give it an example
of some of the input.
So I'm going to go and then find that Google sheet
that we just had with a bunch of dentists.
Then I'm just going to copy all of this information
and I'll say example of the data
and then I'll paste that in.
Okay, so I mean, I just fed in a tremendous amount
of information here, right?
Like this is really, really big.
But with our little fast mode,
plus some pretty precise instructions,
I think we can probably generate a cool skill
in just a couple of minutes
that does this sort of thing automatically.
And after this, I'll have a system
where I can basically just feed into Google Sheet
and then I can generate a beautiful,
customized website for a prospect in like two seconds,
which has information about them
that clearly is customized and so on and so forth.
And then I can just give it to them
as sort of a lead magnet or something.
That sounds pretty fun.
And it's already gone through and it's done some stuff.
Now I'm not using plan mode for this, but you absolutely can.
I just wanted to one shot a skill with this fast mode
just so that I could do something
while I was waiting for the literature review to finish.
As you can see, it's loaded in the skill pattern
and structure from the other skills
as well as the Claude.md.
And now it's just gonna ask me some information.
So where should the output of the skill be?
A local HTML file?
Yeah, let's just use local HTML for now.
How will you provide prospect data?
We'll just do Google Sheet URL.
For images, which approach do you recommend?
Yeah, sure, let's do the unsplash API.
Should the website be a mockup
of what their business site could like
or a pitch page about your services?
Mockup of their site.
Cool, that looks great.
So that's sort of its plan mode analogy.
And this actually initiated plan mode
without me even having to ask basically.
I just make this a little bigger
so you could see the entire chat.
This went through and then turned on plan mode
like on its own.
I didn't even have to ask it to.
And that's what occurs sometimes
when you do bypass permissions.
It'll just choose to create a plan
for a more complicated software build.
Cool, and now I'm going to bypass permissions
and we're gonna go.
While that's occurring,
just scrolling through this literature review.
Looks pretty cool.
It gives me a bunch of information.
Apparently one to 2000.
So that looks pretty fun.
Okay, and then this looks like the little demo
that we put together.
This is a pretty basic demo.
Not that big of a fan to be honest.
So I think we're gonna have to go do some back and forth.
So we did build a website in just a few seconds for them,
which is kind of neat.
Okay, it's now gonna take a screenshot of this page for us.
And as you can see,
it's now accumulated like 19 or 20,000 tokens,
which is kind of cool.
Here's what we got.
Full viewport hero.
Okay, so I'm just gonna say,
not a very big fan of the website design.
I don't think this matches the website.
I'd like you to get pixel perfect accuracy
by screenshotting the comparison back and forth.
Go find some library that allows you to do this as necessary.
In terms of Unsplash,
how are you currently getting your images?
Let's just do that.
That's fine.
I don't really want it to go, you know,
force me to get an API key or something like that.
I'm just gonna have it run.
Okay, that's looking a lot better than what we had before.
I like this.
It looks like it took some photos of areas
that were similar to where this place is located.
And as we scroll through,
we obviously have the information
and the template and stuff.
I don't like how a lot of these images are the same.
So I'm just gonna say, nice job.
I don't like how all these images are the same though.
Get different images.
Looks really clean.
We even have like their phone numbers and stuff like that.
So we're now capable of basically like one-shotting
a website for somebody.
And as you can see,
we can generate these super, super easily and very quickly.
What I'll do now that we have this is realistically,
I'm gonna try it with one row
and then just see how quickly
it can put together the site for me.
Cool.
Now I'm going to test it with some new information
and let's see how quickly it can put that together.
Cool. We've now done the same thing
with Bennington Dental Center.
So that's neat.
We have some images generated and stuff like that.
It is telling me that the reason why we have images
of dogs and stuff is because I don't want to supply
my Unsplash API key.
You know, if we do,
then obviously there'll be much more dentally oriented.
I think that's fine.
Hopefully you guys get the idea.
You could build stuff like this really quickly.
In this case, it took 30 seconds.
So I mean, like what we could do
if we wanted to like build this out as a service
and like actually just like generate custom websites
for people, send them out and so on and so forth.
We could turn the skill into a sub agent
to show you guys how to do later
where basically we can spin up 10 of these simultaneously
and basically in parallel, just generate 10 every 30 seconds.
That's a per website generation time of about three seconds.
And so now that we're generating them every three seconds
with customized information, matching widths and heights
and stuff like that, making it really custom and sexy,
you know, you could do 10,000 leads
in approximately 30,000 seconds.
I don't know how long that would actually take.
Let's see.
30,000 divided by 60 is 500.
So it might take 500 minutes or I don't know,
eight hours for a full 10,000 list.
But yeah, combine that with the scraper,
combine that with you sending people customized websites
and combine that with some other skills that I've set up
to like automate the process
of whipping up instantly campaigns and stuff.
And hopefully you guys can see
we get a pretty solid system in our hands.
And that took me just a few minutes to put together.
Now that we know all about skills,
let's talk a little bit about the next logical thing,
which is model context protocol.
So now that you guys understand sort of how skills work,
which to be clear is that skills are basically
like backend functions that you can run scripts almost
that use the flexible intelligence of AI
and the procedural rigor of Python scripts
and other programming tools to do the same thing every time,
but also allow you the flexibility to air handle.
It's not that we understand that.
Let's talk about model context protocol.
And so the way that I see it is these are just skills
except other people make the skills for you.
I want to say other people, for the most part,
it's like developer teams and stuff like that.
Very similar idea.
You're basically just giving your agent access
to a piece of software.
And then just like it calls its own tools like web search
and bash and the Chrome dev tools, MCP and the screenshot,
all the stuff that we've already looked at.
What we're doing here is we're just calling them,
but somebody else is responsible for putting them together.
Now that obviously begs the question,
where do I get MCPs?
Well, you can just go on websites like MCP servers.org,
model context protocol slash servers, and then MCP market.
I want you guys to know that not all of these
are going to be 100% safe or secure.
These are third party libraries
that people are putting together basically
that try and tabulate the number one MCP skills
and so on, MCP tools and so on and so forth.
But a lot of these are pretty well vetted at this point.
And I'm going to show you at least a couple
that I really like.
The biggest one is probably the Chrome dev tools MCP.
This is one that I use constantly,
basically every day, many, many times,
because it allows your coding agent to control
and then inspect a live Chrome browser.
In my opinion, it is significantly higher quality
than any of the current browser tools that,
Clawed or other platforms have given us.
So I mean, I have this little Chrome extension here
that I can actually use to control this instance of Chrome
through this Clawed tool.
It's developed specifically by the Clawed team.
And I could say, hey, summarize this page.
And then what it can do is it can copy all the text
on this page, so it can extract the page text.
And then it can take a screenshot of it.
And then it can tell me about it and so on and so forth.
I can also have it do things like click.
I could say, okay, star this on GitHub
or something like that.
And then I can give it some additional instructions
and then it can go through, look for the GitHub link.
I don't know, maybe click it.
And then now that we have this thing open,
it's gonna go and it's gonna try and star this puppy.
So that's pretty cool.
But you'll find that it also takes a fair amount of time.
And the Chrome DevTools MCP bypasses that completely.
And it's like a hundred times faster.
And not only is it a hundred times faster,
because you can weave it into skill-based scenarios,
you can actually just run really, really procedural things
in the browser that previously would have taken you
like a fair amount of time to automate.
So I mean, I already have access to this right now,
but for the purpose of this demonstration,
let me just open up a new Clawed instance in my terminal
and then double check the fast mode is on.
It looks like it is.
All I would really do if I wanted to download the MCP
for any tool really now is I would just paste in
this definition you can find right over here.
Basically all MCP tools are going to have some sort of JSON
that looks like this, where there's a curly bracket,
it says MCP servers, it'll say the server name.
There's a bunch of commands in RX,
which really don't matter whatsoever.
But basically you just go on whatever page
of the MCP supplies this information.
You copy this in.
So if you want to install one,
all you really do is you just paste in that little,
you know, JSON snippet that we saw earlier.
And we say, I want to install this in my local workspace.
It's important that you say local workspace here.
What it's going to do is just going to grab that data
and then install it for you.
My case, it's already installed.
So I don't actually need to change anything,
but now I'll say, great, run it.
Now, sometimes when you're using a tool
that requires authentication,
what it'll do is it'll force you to go and grab an API key
or an API token or something like that.
So I'm going to show you guys an example of using a tool
that requires some API credentials in a second.
First, let's just say, okay,
open and navigate to left click AI,
then screenshot the site and tell me about it visually.
So what it's going to do is it's going to open up
that browser, going to navigate to left click.ai.
Now it's going to take a screenshot,
which I think it just did.
Now it's going to read the screenshot
and then it's going to, I don't know,
give me some high level stuff about the website.
So the header is a simple nav bar with the left click logo,
case studies about links and a let's talk CTA button,
hero sections, large, bold, serif, right?
Okay, great.
Go to amazon.ca and find me a bunch of cheap,
but effective light boxes for my studio.
So now I'm going to open this up.
It's going to do the same thing with Amazon.
I'm in Canada, hence the .ca,
and it's going to start pumping in various search terms
for light boxes and whatnot.
I don't know why Twilight is recommended to me.
Must say something about my browsing history.
Now it's going through,
finding a bunch of light boxes and stuff like that.
It's going to take screenshots of the page
and then deliver me a bunch of options
that I could choose from.
And you can see all this occur underneath the tool call.
So this little green boxes are,
little green circles, I should say, are tool calls.
They have the specific name of the MCP over here.
And then they have the tool that they're calling
from the MCP over here as well.
And what they're doing here is now
that it's taking a screenshot and stuff like that,
it's giving me summaries of all the information.
Then it's even recommending a certain one.
Now, a lot of the time,
you can also just type in the name of the tool you want,
and then the word MCP server.
And a lot of these tools will actually have gone through
and then created the stuff.
That'll take me to the clickup page
with MCP server setup instructions.
And then what I'm going to do is I'm just going to copy
over this stuff, just like I did before.
And then we're going to go back to my agent.
So what I'm going to do is I'll just go install this MCP.
I'm going to paste this in.
This includes all of the details and documentation here.
So first thing it's going to do is look for some sort
of configuration file that's preexisting.
It's not going to find one.
So it's going to go and then just make mine.
Then eventually what it's going to ask me to do
is go grab my API key.
So I'll head over here to click up API.
And then I'm just going to copy my API token.
I'll then confirm it.
And then I can copy my token in, and then I'll go back here.
Then I'll say, great.
Here's my API details.
Going to feed that in.
And then every time you install a new MCP server
you do have to open up a new thing.
So that's what I just did here.
Next thing it asked me which workspace I want to connect to.
I have multiple, so I'll click connect workspace here.
Then I can just go back and then I'll say, great.
Do you have access to my ClickUp MCP?
I'll say, awesome.
Create a new content idea called Claude Code course.
Now what it's going to do is scroll through all of my lists.
It's then going to search for various ones
that I may or may not have.
So I have lists called like content ideas
and trends and stuff like that.
And I'm going to ask it to insert it in my main YouTube queue.
So I'm going to do that.
And now you can see there's a task called Claude Code course.
If I go back here to my ClickUp, open up the specific task.
There's now a course that's basically been created.
I don't like how the status is archived.
So I'm going to say, the status is archived right now.
And as you see here, it's now set to record.
So that's pretty neat.
The last thing I want to talk about now
is if we go slash context and scroll all the way up,
you start to get an appreciation for just how many tokens
can get used up by poorly drawn or poorly written MCPs.
And so in this case, I'm not saying the ClickUp MCP
is really that bad.
It's not terrible.
I've seen many, many far worse ones,
but it does consume a hell of a lot of tokens.
As you see here, just the ClickUp search tool consumes 1,600.
The Get Workspace hierarchy is 419.
This one's 1.1K.
If we added all of them up together,
as you could see, my MCP tooling
is now taking up almost 20,000 tokens.
That's actually now more than the system tools,
which previously used to be really, really big.
And what that means is right off the very get-go,
basically like right at the very beginning,
we are already at something like 35,000 tokens or so
before I enter my prompt, before I enter anything.
If you take into account the system prompt as well,
we're now at 40,000.
You take into account some memory files and my skills.
We're not closer to 45.
And this is all before I've sent a message, right?
Keep in mind that 45% is, I don't know,
let's just say 45 over 200.
That's about equivalent to a quarter.
And so one quarter of all my contexts,
and by the way, this is the highest quality section
of my prompt.
If I were to write actual messages here,
this would be the highest quality output.
Basically, the highest ROI section
is currently being taken up by a ton of MCP tools and stuff.
In addition, you'll compare this to skills,
and you'll see that scrape leads only takes up 63 tokens.
School monitor takes up 59, right?
Cross-niche outliers takes up 58.
So it's like, oh wow, a single one of these MCP tools,
like update task, consumes more than basically
all of my skills combined.
It's kind of like, why the hell would I even use MCP tooling
if I can just do a skill instead?
The reason really is just the convenience of it.
MCP, as you see, is pretty easy to set up
where skills, as you saw, take a little bit longer.
That skill back there that does those website designs,
that took me, I don't know,
probably like five minutes end to end to create.
Once I've created it, it's obviously super efficient
and so on and so forth.
But the click of MCP, all I really had to do
was just like log in and then give it one line,
and then I did that.
So basically the way that I personally use MCPs
is I use them aside from the Chrome DevTools MCP,
because I just think that's fire, and I use it all the time.
I use them to very quickly sketch out
whether or not something's possible.
I'll basically go to a new tool
that I wanna see if I can integrate,
and I'll just say, hey, here's the MCP details,
can we do X, Y, and Z?
And then if it can do X, Y, Z the first time,
then I'll say, okay, this is great.
I want you to take what you just did,
and I want you to convert it to a skill instead.
And I want you to go and find like the API endpoints
and stuff, and then build a script that does all that for me
instead of me having to use the super bloated MCP tool.
By the way, have you ever wondered why skills
consume so few tokens relative to everything else?
That's because the whole skill
is not actually loaded into context.
We go to the scrape lead skill.
The only section here that's actually loaded into context
is this section right up here.
And this in markdown format is referred to
as the front matter of the file.
And so what's really cool is the Claude code developers
realized that they could load in a name and description
and then some allowed tools to the front matter,
and then only feed that into context.
And then only if Claude really thinks that it needs to use
us if I specifically say, hey, use the scrape leads file,
then and only then will it actually load it all.
Which means I get most of the benefits
of having access to a bunch of tools
and giving my agent the ability to do
so much of things,
but I don't have to like load all that
in the context immediately.
Which means I get better decision making at the beginning
because performance in prompts are typically the best
the very beginning of said prompt
of the context window I should say.
And then I also don't have to pay a lot of money for it.
So just another point towards Anthropic,
minimizing our total costs,
which I think I very much appreciate.
So just because this is a practical course,
I'm actually gonna show an example of this.
I'm gonna draft out a task.
I'm then gonna try it with an MCP server,
which is gonna be a 10th of the time to implement.
And then if it works,
I'm gonna build a skill to do it instead.
What I wanna do today,
sort of like my task is I want to label my emails.
So what I'm gonna do,
if you think about it,
the task is really I'm going to list last,
I don't know, X emails.
I'm gonna have Claude read them.
And then I'll also have it label according to some scheme
that I put together.
And in this way,
I'm not gonna replace the job of an email manager,
but I'm gonna make the job of an email manager much easier.
And if later on I want Claude to,
how do I manage my emails or whatever,
well, now it'll have some pre-existing labels
and organized structures for it.
So first thing I'm gonna do is I'm gonna go back to Claude.
Let's go to anti-gravity.
I'm gonna do this in the GUI this time,
not the other mechanism, not the terminal,
because I don't think fast mode's super important for this.
And I'm just gonna say,
hey, I want to organize my personal mailbox.
Could you provide me a list of high ROI labels
that tend to work well for personal mailboxes?
Just make sure the thinking tab is on,
because I want it to really think hard.
And then what I'm gonna do is I'm gonna go to
one of my personal mailboxes,
and then I'm going to basically implement this.
I really like action-based, that sounds great.
Keep that for now.
And then I'm gonna open up one of my mailboxes here.
We have tons of different emails.
Most of these are spam, to be honest,
or little demos that I put together for whatever purpose.
I'm also part of what looks to be like a Slack workspace
for one of my businesses.
I think I just did that,
because I wanted to test what this looked like.
Now that that's done,
what I'm gonna do is I'm gonna see
how I can implement the Gmail MCP really quickly.
Great, this looks solid.
How do I use the Gmail MCP?
It's now going to go and search for Gmail MCP,
first in my folders.
And then it'll ask me what it wants me to do.
I want to set one up,
so it's gonna start doing some searches
for Gmail MCP servers.
I'm also gonna do some searching myself.
There are probably three or four different ones
that realistically work.
This looks to be a pretty interesting repo.
So what I could do is I could just use this puppy.
That looks nice.
I just paste this in.
It looks like I actually beat Claude to something for once.
Now it's gonna compare.
Great, let's do it.
It's a personal Gmail.
Is that okay?
Okay, it's now gonna walk me through.
So I'm gonna give this button a click.
Okay, I went through and I got that data.
I'm now gonna paste this in.
It's gonna go find the credentials file
that I just uploaded.
Now it can do what it needs to do.
I just need to restart the Claude code session.
So I'm just going to open up a new one here.
Then I'll go back and then I'll say,
hey, I want you to label my emails.
Ooh, you know, and I don't actually remember.
What was that scheme that it asked?
Hey, I want you to label my emails
according to this scheme.
So now it's going to call the Gmail MCP.
Okay, it's going to check the Gmail MCP tools.
Just figured it out.
We have a bunch of pre-existing labels,
so it's just gonna create a bunch on its own.
The reason why this is occurring so quickly
is because I'm using their fast mode.
So it's about two and a half times faster than usual.
It's now reading through a bunch of emails.
And now it's going to, in addition to thinking through them,
go through and then do said labeling.
And then, you know, it's just gonna continue doing this
for as many emails as I say.
So I think I said that I was gonna do,
I don't know, 15 emails or something like that.
It's just a 10.
So it's 15 inbox emails.
Looks great.
Why don't we do this for 100 emails in total?
Now, if I go back into my email,
which I think was over here,
you can see that I now have different labels.
Just gotta refresh that.
There's action required or reference and waiting on.
So, you know, if something requires my action,
some security alerts and stuff like that,
then that's one thing.
If it's a reference,
so this is just stuff that it's storing
that may be useful for me.
And then there's waiting on down here.
So now that I've demonstrated
that I could do this sort of thing pretty quickly
with a setup that realistically only took me a few minutes,
I wanna turn this into a skill.
So I'm actually gonna pause this and I'll say,
great, this worked really well.
I'd like to turn this into a skill called
Gmail underscore label.
Basically what I want you to do
is just to call the Gmail API directly
and then do all of this labeling for me
instead of me having to use MCP
because skills are just a lot more token efficient
than MCPs.
Check out my other skills
so you could see an example of how to format them
and so on and so forth.
And then write me a skill that effectively does this
as well as uses Gmail scripts.
Feed that puppy in and then press enter.
Now I have some other skills that, you know,
might have something to do with Gmail.
So if it finds them,
then it'll probably just wanna use those.
Okay, cool, it looks like it's rebuilding at all,
which is fantastic.
We're gonna do the Gmail label skill directory.
So it's gonna pump in somewhere right around here.
Looks like I'm running into some error here.
So we're gonna have to do some debugging.
Just gonna paste this in directly.
Okay, and it looks like we're just about to wrap this up.
So now I'm gonna select, say that it can see,
edit my email labels and so on and so forth.
Now that it's done, the authentication flow has completed.
I may close this window.
Going back over here now,
it is created with full Gmail sheets and drive access,
which allow me to do this much faster.
So you guys seeing just how much quicker this is?
100 emails immediately fetched.
It's now reading and classifying all of them
using direct API calls instead of MCP server tools.
And then in addition, you know,
as I showed you guys earlier, we go to Gmail label.
The only thing that's currently being loaded is this.
And this is so much shorter
than like the whole MCP skill stuff.
So it fetched all 100.
It's now categorizing them into five and 95.
So it looks like zero is waiting on 95 for reference
and then five for action required.
That was way faster than what we were doing previously, right?
That would have taken probably like five to 10X the time.
Looks great, why don't we do another 100
and then time yourself.
So tell me how long it took.
Okay, it's now gonna grab all of these.
So it's just gonna continue the filtering process
by using some Gmail stuff.
Then it's also gonna add some timing instrumentation.
That's kind of cool, just cause I'm curious.
Fetch was one second.
So we fetched 100 emails in one second
compared to previously where it took significantly longer
cause I think the MCP tooling had like some built-in thing.
Cool, the end result was it was 36 seconds to fetch,
classify and then label 100 emails,
about 3.6 seconds per email.
Sorry, 0.36 seconds per email
if you think about it that way.
Then it also gave me some breakdowns
and stuff like that of what it is.
I could run this across like my several thousand
outstanding emails if I wanted to.
I could also do things like have it automatically
generate replies to each email.
We could build a sub agent,
which I'll show you guys how to do stuff like that
in a moment where we split each into a parallel tasks
and so on and so forth.
So guys really the limit here.
Okay, next up I wanna chat a tiny bit
about Claude Code plugins.
I personally don't use plugins a ton,
but they are out there.
And so it's fair if I'm building a masterclass course
all about Claude Code,
might as well know what the heck these are.
Simplest and easiest way to access plugins
is just go customize and manage plugins.
It'll show you the plugins that you currently have installed
to see the only one that I have installed so far
is called a cloud-mem at the .mac.
This is basically a simple, straightforward plugin
that basically just adds all of the messages
that send any cloud instance to some memory file.
And then cloud can run searches over it if I say,
hey, what did I ask you about two weeks ago?
So, you know, it's marginally useful.
You then have access directly from cloud
to a bunch of other ones that are somewhat useful.
They have like front-end design, for instance,
which is kind of cool.
So this is Anthropics own library,
which improves the quality,
at least they say it improves the quality
of a front-end work.
You can build sexier and cleaner designs
and stuff like that.
You know, I don't know, it's kind of 50-50.
They say like, if you're doing stuff
without the aesthetics prompt, it looks like this.
And then if you're doing it with the aesthetics prompt,
it looks like that.
Personally, I think both of these are pretty bad.
This one definitely looks better, of course,
but it's not like that much better.
Same thing over here.
So I don't know if the guys that made this
just weren't like actually crazy front-end devs
or anything like that.
But I personally think my workflow
just going to one of these websites
and then copying the screenshot over
and then moving everything into Claude Code
is like way higher quality.
But there are other cool ones here.
Context 7 is pretty nice.
Context 7 basically just allows you to search
through any API doc without really having to like know
anything about the API docs themselves.
You know, if you're working with like three
or four different tools,
you just install this as a plugin
and then it'll automatically shrink
and then compress API documentation
from the sources over to cloud.
And then it can read it in a very token-efficient manner
and do cool things with.
None of these things I want to say are required.
Vanilla Claude Code does really, really well
without any sort of extensions or plugins at the moment.
But you know, just worth us chatting briefly about that.
And then there are two major marketplaces right now
that are sort of, well, sorry,
one major marketplace right now that's supported by cloud.
It's this Claude Code plugins directory,
which isn't the cloud-plugins-official repository.
You can find all of the plugins just by going to plugins
and you'll see there's a big list of ones
that they support right out of the box.
So they have Agent SDK Dev, they have Code Review,
they have C Sharp LSP example plugin.
But then there are also open marketplaces.
So if you go to Cloud Plugin Marketplace,
you'll see that there are a few other ones
that people have put together here.
So this, for instance, is the Claude Code Marketplace
put together by a third-party resource.
I could say Anthropic wants me to take down this website.
That's pretty funny.
With, you know, like chat GPT prompts, let's see.
Superpowers, I don't know exactly what that does.
We have the Context 7 again.
A bunch of Claude Code skills
that looks like some other people have put together,
although not all of these links are gonna work.
And yeah, you know, the plugin installation process
is pretty straightforward, as you guys saw earlier.
So I'll leave it at that.
I think plugins are sort of going to be deprecated
and probably just absorbed into skills at some point.
So I don't wanna spend forever on them.
Okay, and finally, we have subagents,
which I think a lot of people here were waiting for.
I want you guys to know that subagents aren't like a cure-all.
These things aren't actually that incredible.
You can do more or less everything that you could do
with subagents as of the time of this recording,
just with like a normal master agent.
But subagents do speed things up a little bit
and then they also allow you to parallelize your workflow,
which can be quite useful in specific circumstances.
One major issue that people currently have with subagents
is they consume a ton of tokens
and then in doing so can also cost a fair amount,
especially when you go to agent teams,
which as of the time of this recording,
is seven times the token usage
of just using like one single Cloud thread
like I've been doing throughout this course.
But subagents are so pretty useful to know.
And so the very first thing I'm gonna do
is I'm just gonna show you through example
and then we can actually look more into like
the subagent spec and stuff like that.
So you know how earlier we built this system, the skill,
which fetches, classifies and labels 100 emails
with zero failures.
What I'd like to do now is I'd basically like to turn
this skill into a subagent.
So what I'm gonna do is I will remove this
so we're not loading any more stuff into context.
Hey, I'd like you to turn this Gmail-label flow
into a subagent.
The reason why is because I want you
to parallelize your work.
Instead of it taking 36 seconds to fetch, classify
and label 100 emails, I want you to be able to spawn
10 subagents that do all of those simultaneously
and then return the results.
I'd like you to do this using the subagent spec.
If you don't know what that is, do a little bit
of research on subagents.
It's an anthropic and Claude Code feature
that's quite well supported
by our current workspace structure.
And once you've built the subagent using a sonnet-4.5,
I want you to roll it out as a test
and then show me how much faster it is
with some sort of timing instrumentation.
Okay, so I have all that here.
I'm now just gonna feed it into my prompt.
If we open up this little thinking tab,
it's gonna start by researching the subagents
and then building a parallelized Gmail-label flow
that spawns multiple subagents
to classify emails simultaneously.
I'm gonna use sonnet-4.5 because it can load much more
into context, probably read all my emails,
and then it can actually go through this whole process
and then essentially parallelize it
and significantly improve the probability and speed
that these things are working well and fast.
The very first thing it's gonna do
is actually spin up a bunch of subagents to do research.
So that's what this task little bubble is, right?
When it says research Claude Code subagents,
what it's actually doing is it's giving this task
to a subagent called the research subagent.
There's another subagent as well,
like the search subagent.
So it'll actually search through my workspace
to see if there are any pre-existing subagent patterns.
And then because it's capable
of spawning these simultaneously,
typically retrieves the results much faster than normal.
So that's kind of fun.
It's a little bit meta of Claude Code to do that
without really understanding
what subagents are out of the box.
Okay, it's now going to create a subagent directory
inside of my .cloud folder,
and then it's gonna populate it
with all the subagent spec parts and everything else.
And what's really cool is we're using subagents
alongside skills in this instance.
And that's what I'd usually recommend.
I don't recommend just creating subagents
for the sake of subagents,
unless they're very specific ones.
I'll show you guys a couple of them in a moment.
But for the most part, use them where it makes sense.
Use them in situations where you want to parallelize
the workflow and be a lot faster.
Okay, and then because we just generated the subagents
in a previous instance,
we actually have to call the subagents
in another Claude Code instance.
So I just had to make a new one, basically.
What it's gonna do now is spawn a bunch of subagents for me.
Okay, so that's what these tasks are.
So as you can see, classify email chunk,
one, two, three, four, five, six, seven, eight, nine.
So all 10 classifiers are now running in parallel.
We now have all 10 task outputs here, which is pretty cool.
It's now absorbing all these task outputs.
And we're operating at a much higher level of speed
than we were before, right?
So now it's recording the time,
and then it's going to merge and apply.
Classification took 19 seconds,
while clock time for a thousand, sorry, a hundred to complete.
And then let's see the total time speed up.
Okay, so in this instance,
because we ran the same number of emails,
we did 100 versus 100.
We only saved six seconds.
So what I wanna show you guys now
is I wanna show you guys how to do this at scale.
So instead of, you know, a hundred emails,
I wanna do a thousand.
Excellent work.
I'd like you to classify a thousand.
The benefits of the speed up are most likely
not going to be at the same level of scale,
but they will become evident when we go
at a much higher level of speed at a scale.
So now we're gonna run 1000 of these,
aka 1000 emails split into 10 chunks of a hundred
that are being classified in parallel with 10 subagents,
considering that every time took, I think,
like 19 seconds or something like that per,
I think it's gonna be a lot faster.
So we'll see.
Okay, some of these task outputs
are now starting to complete.
It's been maybe 15, 20 seconds.
I'm not sure exactly how long,
but as they're all coming back,
you see these little gray bubbles
turn into green bubbles.
Okay, we ended up having an issue
where the prompt was too long,
essentially because all of these subagents
returned massive strings of text with every single email
for whatever reason, when you combine all this
into the parent thread, just way too long.
And it ran out of context.
So what it is, I just copied over everything.
And then I gave it to another instance up here.
And I basically said,
hey, this is a little too long right now.
I keep running into prompt too long output.
So I think we ran out of context.
I'd like you to modify this so we don't run out of context.
If the subagents don't have to return the actual text
to the parent nature, that would be ideal.
Then I ran it in parallel for all 10.
And now we're just redoing it.
At the end of it, it labeled 987 out of 989 emails.
I didn't time that end to end.
If I had to guess,
it'd probably be somewhere around like a minute or so,
which means we are now classifying a thousand emails
in a minute, whereas 100 was at 36.
And this is really the power of subagents.
Subagents basically allows us to take some query
and then split it up into five, 10, 15, 20, whatever.
Run them all synchronously at the same time.
And then once they're done,
they just take the outputs of each of these threads
and then combine them into the main one.
And so, there are a couple of other use cases
for subagents, but for the most part,
it's going to be something like this.
Like if you really wanted to use subagents
in an economically valuable fashion,
this is usually how you would do so
as of the time of this recording.
Subagents are fantastic, but keep in mind,
most of the time they're gonna be less intelligent
than the parent agent.
And so you wanna reserve the parent agent
for taking the outputs of each of these subagents
and combining them and doing something with them,
not just spawning 500 things in parallel
to run for no reason.
Strategically speaking, some other things about subagents
are try and make the task definitions as simple
and as straightforward as possible.
Like I could have given every one of those subagents
more context, I could have said,
hey, I don't just want you to do the classification,
I want you to do everything.
I want you to do the classifications, the merges,
the applying the labels, et cetera.
But because the subagents are dumber
and because we're spawning a bunch,
we're multiplying probabilities here.
If there's like even a, I don't know,
let's say there's a 95% chance
that the subagents gonna work, right?
That's a 5% chance that it's not gonna work.
And the way in statistics that you calculate
the probability of a bunch of things occurring in sequence
is you just multiply them out.
So what this is, is this is 0.95 times 0.95 times 0.95.
Basically what this is equivalent to is 0.95
or raised to the three.
And so if we spawn three subagents, okay,
the total probability that all three of them will work
the way that we wanted them to,
but just go back over here,
is 0.95 raised to the three here.
So 85, AKA 85.7%.
You know, I mean, if I'm running 10,
the probability is now down to 59%.
If I'm running, I don't know, 50,
then the probability is down to 7%.
Obviously I wanna maximize the probability
that all of these subagents complete
in the time that I've allotted to them and stuff like that.
Not only for my own token count issues and my consumption.
So you guys see back here,
like I'm now at 173 bucks in additional usage
on top of my Claude code usage,
not just from this course of my idea,
but I'm doing a fair amount.
But also for like completeness sake,
if I malformed the output
and then my parent agent can't collect it all right
and do something right with it,
well then what I've done is I've just basically wasted
that whole query because subagent prompts are ephemeral.
They only exist for like a short period of time.
Their context windows are all self-contained.
Do I really wanna rerun that thing a hundred times,
even if it's cheaper?
Probably not, right?
Next up, I wanna show you guys how to create
what I'd consider to be the three most useful subagents
as of right now.
So what I'm doing is I'm actually having Claude code
create these as we speak.
One's called code reviewer,
the other is called researcher,
and the last one's going to be called QA.
And we're going to insert all three of these agents
into this folder here alongside email classifier.
And then I'm gonna update my Claude.md
to reference the proposed workflow.
Then I'm gonna show you what all that stuff looks like.
Now, in order to use agents,
what we actually have to do is we have to exit
a specific instance that we generated the agents in.
Otherwise we're not gonna see them as available
in our task definition.
So I'm just going to create a new instance of Claude code.
What subagents do we have access to?
I also refresh this so we could see them all.
And as we can see, we have four.
We have code reviewer, QA, research,
and then email classifier.
Okay, what is the proposed workflow
every time we develop some software?
What I want it to do now is I want it to go through
and then tell me, first we write the edit,
the code, and the parent agent.
Then we code review, which spawns a code reviewer subagent
and the change falls, fixes any blocking issues.
Then we do a QA, spawning a QA subagent on the code,
generates tests, runs them, reports results,
and fixes failures.
Then finally we do a ship.
So now that we have all that ready,
let's actually go and then let's use our new workflow
on the flow that we just created before.
So I think it was the Gmail-label.
Use our new workflow on Gmail-label.
It's the skill that looks through my inbox
and then labels emails.
So what I want to do is I want to read through
the Gmail-label skill to understand what we're working with.
So it's going to read the skill.
That's also going to go through all of the scripts.
But I basically want us to take these scripts
and then apply our little flow.
So the first thing it's going to do is run
the code review agent on all four scripts.
And as you can see here,
we can run these in tandem in parallel.
So first we're going to code review,
and then we're also going to generate tests
and run them for the Gmail-label scripts.
So we're going to use both of these,
and then we're going to use them to feed back
to our parent agent.
Our parent agent is going to make changes to this code
and significantly improve the quality of said code.
Now is this like required to do every single time?
No, as you guys could see,
we're capable of writing some pretty damn good code,
but knowing a lick of code,
with just like the vanilla Claude Code installation.
This sort of stuff becomes more and more valuable
when you're working at enterprise
and you're creating code that requires the ability to,
one, be like really secure and verifiable by both agents
and then human beings if they read them.
And then two, to like account for all possible edge cases.
You know, in my case,
I don't really care too much accounting
for all possible edge cases,
because most of the software I'm making
is for my own internal tooling.
You know, it's like a one-off landing page
for a client to use, that sort of stuff.
You know, if I'm working in a big business,
working in a Versel or I'm working in an open AI
or I'm working in a, you know, I don't know,
Oracle big database or whatnot,
this stuff becomes significantly more important.
And that's where these sorts of code design patterns
become valuable.
Okay, so we're still waiting on the output
of the other task, but if I scroll down here,
you can see there's actually some recommendations already.
This is being provided inside of this task output,
so it's not written very well or nice.
So we're gonna have to squint a bit,
but code is correct, readable,
it handles errors appropriately.
Batch fetching uses 100 per batch,
but could use the Gmail API max
of a thousand requests per batch.
That means that we could significantly improve
the total efficiency of this flow.
And that's one piece of value
that the code reviewer has already given for us.
Then we have some callback stuff.
So basically it's identified an error or an issue,
which is quite useful.
It's giving us some insights on the readability
and, you know, a little commenting that we could be doing
to make the code better and so on and so forth.
Okay, now the tests are completed.
So it looks like we've passed most of the tests.
There's only one that had a wrong exception.
And now it's feeding in all of this information
to the parent agent.
The parent agent is gonna go through and do the fix.
So 16 to 18 characters,
it's gonna jump through,
accepting uppercase and variable length hex IDs.
No idea what that means,
but of course this agent is now thinking
dozens of times faster than I'd be able to.
So I'm just gonna trust that it's doing well.
And then front load all of this double checking,
triple checking, QA, and so on and so forth
to minimize the possibility of longer term errors.
So that looks great.
We've now run our new flow,
which has yielded significantly better benefits.
Okay, great.
Now use the research sub agent
to go and find me the best MCP server
currently available for PandaDoc.
So now I wanna show you guys
the value of the research sub agent.
This has now spawned one of my research.
So it's going through,
it's doing tons of research simultaneously,
trying a bunch of different search queries
and so on and so forth.
It's now returned one of the web search results.
And as you can see,
it's also doing tons of different like HTTP requests
and stuff like that simultaneously.
Now I should note that like we already
technically have a research sub agent built in,
but you can modify that research sub agent flow
by telling it,
hey, you know, I want you to use specific sources.
I want you to trust these websites.
I want you to preferentially go directly to the API docs
and stuff like that.
And so that's what that research sub agent allows us to do.
It allows us to research things
the way that we typically research things,
which is gonna be different
from just like doing a general Google request for,
I don't know, good APIs for PandaDoc.
So again, just to really impress upon you
the value of these,
really a big chunk of value is
it's cheaper to use Sonnet as of right now versus Opus.
And so rather than do your research or do your low,
you know, leverage or low ROI stuff,
like reading through a large amount of data
to extract something,
it's better to use the cheaper models.
The next is that it's parallelizable,
which just means that you can spin up multiple simultaneously
and then wait for all their inputs
as opposed to going one at a time.
Like for instance, if this is us,
and this is sort of our task flow,
let's say, you know, this is sort of the serial method,
which is what we were doing before.
Let's say every search takes one minute.
So, you know, this is task one, takes one minute.
This is task two, which takes one minute.
And then this is task three, which takes one minute.
I guess this is two and then this is three.
That means in order to get to, you know,
the start of our query to the end of our query,
Claude Code takes three minutes in total, right?
Well, obviously the parallel approach here is a lot better.
We start, and then what we do is we just spin up
three different boxes here simultaneously.
And now these all take one minute.
And, you know, by the time that we end,
what we've done is we've basically taken one minute
because each of these are executing side long
sort of with each other.
The last major benefit is the way that the context works.
And so there's some situations like a, you know,
reviewer sub agent where it's actually beneficial
not to have any of the context of the code.
It's not to have any of the biases of the decision-making
of the previous parent agent.
And sometimes, you know, choosing a different model
to do some of the reasoning can, you know,
reveal things that maybe the parent agent
didn't necessarily think of.
Sometimes it makes more sense to look at the ground
at your feet, for instance, the dumbness,
rather than look up in the sky at like all the complex
advanced stuff.
Same thing with sort of like a QA agent.
The value of both of these is they don't necessarily
know what's going on in terms of the broader world.
All they're really focused on is the code itself,
the way that it was written.
And so they get to optimize objectively at like the way
to make that thing as efficient as possible.
And that's sub agents in a nutshell.
It doesn't have to be any more complicated than that.
It's basically just a folder structure
and it's very similar to skills.
My recommendation is use this in conjunction
with things like skills to accomplish preexisting workflows
many times faster because of parallelization.
But don't rely on sub agents because a lot of the time,
the time it takes to spin up a sub agent
for a simple query can be just as long as it would take
to use just a parent agent to do the thing instead.
While sub agents sound really sexy,
and obviously everybody wants to have giant fleets
and swarms of them working for you on your behalf,
be pragmatic and be efficient here.
And now it's time to discuss one of Claude Code's
most commonly hyped and misunderstood,
but also pretty powerful features, agent teams.
If you're unaware, Claude Code recently unveiled
new functionality where you can orchestrate a team of agents
and you actually don't do the orchestration yourself.
You can actually spin up a team of agents
that are managed by another agent for you.
And then all you really need to do is just report back
to that manager agent, let them know what you want to do
and so on and so forth.
Obviously, given the fact that this is pretty interesting
at first glance, a lot of people are pretty stoked about it
and they've made tons of videos talking all about
how agent teams run their whole life
and have revolutionized programming and so on and so forth.
Hopefully in this module, I'm going to show you that
this is more of the same and agent teams are just another way
that you can parallelize your workflow.
So the way I want you to think about agent teams
are basically just a more advanced version of sub-agents.
Basically, both agent teams and sub-agents
are a mechanism of parallelization.
Like we had earlier when I showed you that example
of doing a bunch of classification,
we have a task and we could do the task one by one.
And if we do the task one by one,
what we're doing is we're incurring a fair amount
of fixed time cost.
Not to mention there are some instances
where task steps aren't even necessary.
And so if each of these are one minute,
obviously that's one minute plus one minute
plus one minute equals a total time of three minutes
to complete the task.
Multiply this by 60, you get an hour, an hour, an hour,
three hours.
I'm sure you can start understanding why we parallelize work.
Much better to be able to spin up
three separate solutions,
have those operate simultaneously
and then merely integrate their results into one thread.
Okay, in a situation like this,
assuming one, two, three, take one minute,
obviously the total time spent is about one minute.
So just like subagents allows one agent to spin up
a bunch of these different tasks and then parallelize them,
so too do agent teams.
It's just they operate one level even higher.
Instead of splitting one thread into three,
what you end up doing is you basically end up splitting
as many threads as you want
into as many sub threads as you want as well.
And so in this specific case, basically,
I have one what's called team lead agent.
And this team lead agent, as opposed to doing one, two,
three, four, five, and six himself,
what he's doing is he's splitting things up
into two separate agents here,
having them both run three subagents on their own
and then combine that into one call.
At the end of it, this agent then combines them back
into the main thread and then can reason about things
and so on and so forth.
Much in the same way that if you think about it,
organizational hierarchies work.
You'll have like a manager up here in a business,
and then you'll have, for lack of better words,
like grunts down at the bottom.
The manager tells the grunt what to do.
The grunt goes, does what they want, and then reports back.
So too, do we have sort of the same system
with subagents and now manager agents as well.
And then you basically sit outside of this whole thing,
just watching it all occur and then nudging different people
within the organization or letting the team lead know
you wanna change something where necessary.
So if you break things down,
subagents own all of the context window
and the results return to the agent that called them.
So in our case, we have a parent agent,
we have a child agent.
Our child agent owns its own context window
and the results, every time, always go directly
to the person or the agent, I should say.
Look at me, anthropomorphize and these damn things
that called it.
On agent teams, they own their own context window completely.
They're also fully independent.
And so they don't necessarily have to return their results
back to the caller.
In fact, agent teams can communicate between them.
So earlier, where we saw the grunts communicating
with the manager, grunts also have the ability
to basically communicate between each other.
And while I think that this is ultimately less powerful
or less effective than communicating with the manager
because the manager is responsible for synthesis,
there are some instances where, you know,
Grunt 1 does have a interesting revelation
or time saver for Grunt 2 that could save them
a fair amount of time.
And in that way, this sort of cross contamination
and cross pollination of ideas,
while consuming significantly more tokens
can lead to a better quality final product.
And that takes us to communication, right?
With sub-agents, you always report back
to the main agent only,
but here teammates can message each other directly.
Basically, what occurs in an agent team is
they build this mutual scratch pad,
which is almost like a message board or a BBS board,
if you guys remember from way back in the day.
It's like a forum, it's like they're on mini Reddit
and they'll post tasks that they're currently working on.
If they have any questions,
they'll ask specific people
that are responsible for those things.
And they'll always just have that stored in their context.
So if they, you know, have a question from one person,
they can prioritize that question
and then go and find it in another context
and immediately reply.
In that way, you could save individual agents
significant amounts of time.
In terms of coordination here,
the main agent manages all the work,
but with agent teams,
it's a shared task list with self-coordination.
So just like we had a little Trello board
or maybe, you know, a click up task list
or something like that.
So too do these agents work off the JSON equivalence.
They say that sub-agents are best for focused tasks
where only one result matters,
whereas agent teams are best for complex work
requiring discussion and collaboration.
You know, this is just one of those
like little marketing isms.
The definition between focused task and complex task
is very, very fuzzy,
and there is no real delineation between them.
It's sort of like how there's a certain point
at which a hill becomes a mountain,
but nobody could tell you exactly how many feet high
the hill needs to be or whatever, right?
It's just one of those things where when you know, you know.
And finally, the token costs of sub-agents are quite low,
relatively speaking,
whereas agent teams are very, very high
because every teammate
is actually a whole separate clot instance.
So when you scale up and spin up a bunch of these,
you can use a fair amount of tokens quite quickly.
Now I should note that agent teams
are not enabled by default
because they're what we call an experimental feature.
This may not necessarily be true
by the time you're watching, by the way,
but for now they are.
They have set them to off essentially by default.
And so only advanced users really get to peer
behind the curtain and use them.
The way that you enable them
is you edit your settings.json in your current workspace,
and you just create this sort of little string.
You have this curly brace, you have env, env,
you have clod code, experimental agent teams,
you set that to one,
and then you have some closing curly brackets.
You don't need to worry too much about that.
We'll do that in like five seconds.
Finally, the cool thing about agent teams as mentioned
is you can't just,
it's not only that you can communicate with the parent agent,
you can communicate with all of the agents.
So if, I don't know, you want to context switch
and tell agent three in the sequence
to do something different than it was currently doing,
you can absolutely do that really easily.
There are two different ways to do so.
There's what's called in process mode
and then split pane mode,
at least this is the time of this recording.
One is where you basically just like alt tab
through all of them.
The other is where there's just multiple panes.
And so you'll see agent one over here,
you'll see agent two over here, agent three over here,
and then you'll kind of get their feed.
I will note, I've done this before,
unfortunately, because Claude Code renders your,
it's not just like a simple text terminal.
Basically they're like rendering this 2D image
constantly on your screen.
It can consume a fair amount of compute.
So I don't actually like using it that way anymore.
I basically always use it in process,
but I'll run you through what that looks like
if you did want to use split pane mode.
And then obligatory agent team tokens cost way more
because you're spawning tons of different cloud instances.
And every single one has its own context window
and can do its own stuff.
So if you have like 10 active agents running,
you're gonna consume about 10 times the context,
if not more, because there's also gonna be
some coordination and communication lag and overhead.
So they have some recommendations here.
They say use Sonnet for teammates,
keep teams really small because every teammate
runs its own context window.
So token usage is roughly proportional to team size.
Keep the spawn prompts focused.
We don't know what those are.
So I'll tell you that in a second.
Teammates will load their own cloud MD,
MCP servers and skills automatically,
but everything in the spawn prompt
will also add to their context from the start.
Clean up teams when the work is done.
So you can actually roll them down or shut them down.
And then, yeah, agent teams are disabled by default
because they don't want anybody blowing $10,000
on agent teams in the day,
which you can absolutely do if you're not careful.
That's why limits are so important.
Okay, so first things first,
we have to actually enable agent teams.
So I'm just gonna jump over here to this URL.
And then I'm just gonna copy all of the text on this page.
And then I'm gonna go over to anti-gravity,
open that puppy up.
And just for the purposes of this example,
I'm actually just gonna open a new folder.
So go to my Mac and then I'll say agent teams example.
Okay, and I open that.
And then what I'm gonna do is go over to cloud,
paste this in, and I'm gonna say enable agent teams.
I'm gonna go bypass permissions,
close this puppy out so we can all see it.
Maybe bump this out a bit
so you guys can always see the text.
So it's now added my settings.json here
and it's kind of fixed it.
Okay, so this is now good to go.
And it's enabled this across my global workspace.
So it's not actually even in my file.
Let's start with a really simple example of agent teams.
So I could show you the parallelization aspect.
And then what we'll do is we'll actually go
into an open source code base.
And I'll use agent teams to act as both code reviewers
and then also debaters to debate between each other
until they determine that consensus
on how to make the code even better.
So our first super simple example is gonna be,
I'm designing a simple personal website for Nix or Iave.
Generate three agents using a team
and create three fundamentally different designs.
Open all three once done and I'll compare, contrast
and give feedback.
Also make sure they know everything there is to know
about me so nobody is waiting on anything.
So I'm using a terminal for this just because the terminal UX
is much nicer for agent teams than the GUI UX.
I'm sure that'll change at some point, but yeah,
I also have fast mode on up here,
which is just allowing me to do this a little bit faster.
And so as you see, what's occurred is the agent,
this parent agent here, Opus 4.6,
sort of made the executive decision
for its very first task, basically.
Oh, that's so cool, I didn't even know I could do this,
to do research on Nix.
And so after it's done the research, basically,
it's now gonna spin up three agents, one for site one,
another for site two and another for site three.
I really gotta figure out how to do this with hotkeys,
it's super annoying.
And then these three agents are gonna go working
on this thing simultaneously and independently
and then they're going to combine those three websites
back into just like we did with subagents,
sort of that main thread.
But what's cool is these three different agent teams,
since they're all individual Claude Code instances,
they get to do a variety of different things.
They also get to access their own agents,
use their own code base and stuff like that.
So what's really cool is we have three agents
now working in parallel.
The first is called Design Minimalist,
the second is called Design Dark,
and the third is called Design Warm.
I asked for fundamentally different types of designs,
which is why they're doing this.
Now, if you wanted to see all these agents
run simultaneously,
all you'd have to do is just go shift up or down.
And so right now I'm in the Team Lead context,
but I could actually go down here and then press enter.
And now I'm in the Design Dark.
As you see here, we got a ton of information here
with some context about who NixRyf is,
and then it says you're designing a personal website,
create a single self-contained file.
It's now creating a bold dark tech website.
We could also go up to the main Team Lead
and then you could see that it's let me know
that the Design Minimalist is done
and it's still waiting on Design Dark and Design Warm
to finish their builds.
So I mean, like how exactly is this different from,
I don't know, like sub-agents right now?
Well, it's different from sub-agents
in that you can treat every one of these
as basically having its own whole Clawed code instance
available to it, okay?
Whereas before every individual sub-agent
only had access to the contacts that the parent agent gave,
realistically, what I could do is I could add a Clawed.md,
and all three of these would have access to Clawed.md,
you know, style guides and stuff like that.
So I'm gonna take a look at this, okay?
Saying that it's all done now,
and it actually shut down all three of those agents as well,
which is really, really important.
If they're constantly running in the background,
you're also gonna be consuming compute resources
just as well as UR tokens.
Now I'm gonna compare which ones I like more.
This one up here is building at the intersection
of AI and human ambition.
Wow, look at that, that's nice.
Geez, insane.
It's got a couple things wrong here.
Definitely have more than 150K YouTube sales,
but what are you gonna do?
Looks like it does have my links, which is kinda cool.
This is like, you know, dark coding one.
Look at that, isn't that neat?
And this one over here is very interesting.
There's no picture of me on it,
but hey, what are you gonna do?
That was my little nightclub promotions party.
Business, that's a hell of a throwback.
And yeah, what happens if I click this?
Okay, cool, we go back to our YouTube.
That's really exciting.
So I mean, like, I don't know, maybe, hmm.
Maybe I really like the first one.
So now what I'm gonna do is I'm gonna go back
and I'm gonna say, hey, I really liked
the warm narrative option, looks great.
I'd like you now to spin up three more agents.
I then want you guys to do research
on effective design principles
and copywriting principles that convert.
Once done, I want you to spin up a bunch of agents
to iterate on this design
and come up with their own flavors or versions,
then report back to me.
So now what I'm doing is I'm taking, you know,
this winning design here, the warm one,
it's gonna take this warm, beautiful thing,
and then I basically want it to like iterate on it even more.
And as you saw, this occurred pretty quickly, right?
I mean, this took me maybe like two minutes or so.
Is it perfect?
No, but because it's not perfect,
I basically just wanna have Claude do a bunch
of iterations on it and then give me what I consider
to be an even better version,
which I think it can do pretty quick.
So it's gonna spin up a bunch more.
We have research, copy, research, design,
and research examples.
This is a good, you know, actual use case here.
It's doing three research agents in parallel.
We have one that's figuring out like strong design principles
based off of, you know, winning combinations.
There's another that's doing some copywriting fundamentals.
And then the third that is looking
for high quality creator sites.
So Ali Abdel, guy that I like, Hormozi, obviously.
Dan Coe, these guys are perfect.
It's more or less exactly what I'm looking for.
So it's gonna go do a bunch of research on them.
And then it's going to incorporate that
in presumably some other type of designer.
I could see the status by going shift up and down.
So this person here, research copy,
it's looking up, I don't know,
best hero copy formulas, personal brand,
scannable web copy best practices,
David Ogilvie copywriting principles,
headlines that work, right?
If I go down here to research examples,
this agent is now writing up
a bunch of high quality website styles.
It's then analyzing the websites
and, you know, giving me all of the copy
and stuff like that.
Presumably it's going to integrate this
into something nice.
But if I go back up to the team lead,
then I can see that it's, you know,
basically just waiting on all three of these to finish.
What's cool is these three all have their own token usages,
as you see here.
So 53,000, this one here is 56,000,
this one here is 50,000.
When they finish, it then says idle
and it tells you how many seconds that the agent is idle.
This is, you know, mildly useful,
obviously not utilizing your cloud agents
is one of like the biggest issues with them.
So what this thing is going to do
is basically wait for these other two to finish.
And then if these other two don't finish
after a certain amount of time,
they'll actually just wind down the research design agent
to stop consuming my compute and stuff.
Probably the research examples
is going to take the longest time,
just because I think that that's like
less of a clear cut definition of done, but we'll see.
And then what's really nice is these are cheaper models,
right?
58,000 tokens on the cheaper model,
56,000 tokens on the cheaper model,
then only 2000 tokens on the most expensive model.
And so we haven't actually integrated all of that stuff
back into the main yet, but as these finish,
they will eventually, you know,
take all of their tokens and then bring them back in.
And so this token count will increase significantly.
Okay, now that all three of these are done,
we've collapsed these three agents into the team lead.
Now we have these big design principles doc,
research copywriting doc, you know,
research site example doc.
And because I've empowered the team lead
to be able to spin up new agents based off of, you know,
various things like the conversion rate,
the copy, the creative and the style,
it's now generating new ones.
So there's an iterate dark, iterate conversion.
I don't know how many of these it's going to spin up,
but it's definitely gonna spin up some.
In the meantime,
we also have these really dense research summaries.
So I can actually open this research design principles doc.
If I just scroll down a bit so you could see,
we now have things like there's a Z pattern layout.
Since the eye starts in the top left
and moves to the top right,
your nav and CTA should be at particular places.
There's also an F pattern layout
and different actionable recommendations on color psychology
and so on and so forth.
I mean, this is a tremendous amount of text.
Is this the most efficient way to like get all this across?
Probably not.
But because these models just think so much quicker
than we do at this point,
we don't really need it to be as efficient.
We can actually just throw a tremendous amount of text
out of prompt and it can actually do a pretty good job.
What I really like about this is it took key inspirations
from different people.
So in this case, Justin Welsh's upside down homepage.
I really liked Justin Welsh, so that's great.
Dan Coe and Seahill Bloom's dark premium,
bold typography, origin story
is some sort of cinematic centerpiece.
Like it's taken inspiration from all these different people.
Then it's combining them with slightly different
copywriting directions to create things
that are ultimately new
and presumably going to be quite different.
And you know, I think a lot of people rag on agents
and AI is not really being creative.
But like what is creativity if not just like combining things
over and over and over again
in like a million different combinations.
I'd wager most things that you probably consider
to be creative are things that like
whose preexisting pieces and principles existed before
and AI just combined them into something
that maybe hadn't really been put together in that way.
There are certain sentences
that have never been said before or written before.
You could be the first to write one.
Some of them are quite creative.
Okay, and we are done.
So the first site here is I hope aspiring entrepreneurs
build their first 25k month automation agency.
I like this, this is really clean.
That's actually quite the value prop.
We do have an issue with the button, obviously.
So the thing is this model
was not given the ability to screenshot.
I bet you if I did,
that would have been pretty straightforward.
So this is a good opportunity for me
to update the cloud.md and say,
hey, you know, you can do some screenshots.
Still, this looks really great.
Step one, watch the free training.
Step two, join maker school.
Step three, build your agency.
I mean, honestly,
the fact that this is just a couple of minutes,
this is so much better than what I could have done
in an equivalent amount of time.
It's not even funny.
And not only did I generate one, I generated three.
It's not the dark one, right?
That's pretty clean.
I like that.
This must be the Danco one.
There has to be a faster way to matter.
Ooh, that's clean, right?
Again, it's taken that main website
and then it's iterated on it
based off of different styles and different approaches,
which is more or less exactly what you do
in any sort of copywriting and so on and so forth.
So I really like this one.
I mean, this one to me is probably my favorite.
You wanna build an automation business,
but you don't know where to start.
I really, really like that.
So I think I'm actually gonna take that.
Great work.
Build in screenshot functionality.
Because you don't have the ability to screenshot,
a couple of things stand out.
Also get pictures of me to put on the site.
Let's choose the first one,
which is the conversion machine.
I think it's the conversion machine, right?
Yep.
Also, we need to update some stats.
We have 2,100 or 2,200 people in Maker School right now.
You can check that out just by Googling Maker School.
And then, let me see, what else do we have?
Grab the image of me, Alex Hormozi, and Sam Ubbins
and put that somewhere on the site
and add more to the site.
Right now it's good,
but I want it longer and with pictures of me.
Also see if you could build some sort of animation
on the main homepage.
I think that would add a significant amount
of visual appeal.
Right now it's pretty vague.
I do quite like the gradient though.
While you're at it, spin up another three
and continue doing more iterations, more sections, etc.
Okay, as you can see, we're now searching significantly more
of the total space of possible websites here.
Because not only did I spin up three initially
to build me these and then three iterations
on the one that I liked, I'm now spinning up another four
based off of the one that I really liked
from that previous iteration.
And so in that way, if you think about it,
what we're doing is we're taking this idea of what I want.
We're testing a few variants.
We're seeing which ones actually look good.
These are two no's.
We're spinning up even more.
We're seeing which ones of these I really like.
Okay, these ones are all now.
And now we're spinning up another four.
And eventually if you continuously do this process,
you'll get to a website or a web app or a property
that's like five times better.
Because we have essentially, instead of just picking
one option and stopping there, we've really thoroughly
explored the space of all possible opportunities
and options.
And so that's something that agent teams really help with.
I know my tech's kind of slanting up, but bear with me.
And while I'm doing that, we see that some of these
are already starting to finish.
So iterate scroll, just finished.
That was pretty fast.
Looks like the editorial magazine style site completed
with all 13 sections as well.
We got the conversion site fully rebuilt
with all the changes now.
And now we're just waiting on the split.
There it is.
It's now gonna open all four of these.
And so for 150,000 tokens or whatever the hell
I just spent essentially, I've now been able to draft up
what I consider to be a pretty clean and sexy website.
I have that picture that I was looking for.
I have this.
I mean, this is great, right?
One thing I'm missing is that little video page,
but hopefully it's clear.
I mean, I could build, God, websites are just the tip
of the iceberg in terms of what you could build.
Have my picture here.
I got my whole business partner, Shoma.
That's me during COVID doing a little videography shoot.
That's when we played bowling down in the Philippines.
I mean, like the stuff's super straightforward.
Also, I really like this other editorial site.
I might end up just choosing that.
That's super clean, right?
Those harsh corners and the photos and stuff, very nice.
Okay, but if you just use Agent Teams
to design a bunch of websites,
you're honestly leaving tons of potential on the table.
Most people are kind of uncreative.
And so obviously most of the demos you're gonna see
on the internet are gonna be like,
watch me rebuild this website 400 ways
like I just showed you.
You can go a lot deeper than that.
And actually the number one recommended use
for Agent Teams right now, at least my recommended use
is using it on pre-existing repos
to do a tremendous amount of research
in a short period of time.
So what I'm gonna do next
is I'm actually gonna go over here.
I'm gonna delete all of these websites that I built
because the websites are basically only worth the tokens
that they're printed on, okay?
I'm gonna full screen this and then I'm gonna say,
clone this and then open an anti-gravity instance
inside of it.
Then I'm gonna paste in one of the repos for OpenClaw,
which I've made some rather scathing videos of.
OpenClaw is totally open source,
which means you can muck around the code,
take a peek at the way that things were written,
make improvements if you really wanted to
and so on and so forth.
Looks like it doesn't know what anti-gravity is.
Anti-gravity, the app, it's like VS code.
Okay, cool and it ended up opening up OpenClawed
inside of this.
As you see, we are now like in the folder of OpenClawed.
It's just instead of it being on GitHub,
it's now on our computer.
It's just a quick and easy hack.
You can basically do whatever the heck you want
with these repos.
Once you're inside, I'm just gonna open in the terminal
because I think I can probably go significantly faster
in the terminal.
Let me just open this up.
Okay, I have it right down over here.
Then I'm gonna pop this puppy open,
make it go full screen by clicking that button
on the top right.
And now I'm going to use agent teams
to go through this massive, massive file
and then make improvements.
Taking a look at this prompt,
I've wrote OpenClaw is great,
but there are a bunch of security issues.
I don't know exactly where they all are yet,
but I want you to find them.
First, create a team with 10 teammates
to look through the code base very quickly.
Split things up logically based on file size, et cetera.
Then spin up four agents to document
all of the security issues
and a fifth and sixth debate agent
that plays devil's advocate back and forth.
Use Sonnet for each teammate
so as to make use of the longer context window.
When you've identified all the security issues
and then spin up one agent per security issue
and make changes.
Ensure each agent works only on the security issue
it is given to minimize overlap.
And if one agent steps on another agent's toes,
have them rectify by talking back and forth.
Now, I'm not going to fix this code base
throughout the course of this video
because that'll probably take several hours
for it to go through, make changes.
And then obviously there's Q&A and testing
and so on and so forth.
This is pretty similar to the workflow
that the creator of this godforsaken repo.
And if you're curious about why I have strong opinions
on this, just check my channel for one of my videos
from like two weeks ago or so.
But this is pretty similar to the workflow
that they're currently using in order to manage things.
But suffice to say, you can use an approach like this
on basically any open source library,
not just to identify security issues,
but also to improve the product.
You could come up with different product angles.
So you could have it go through, spawn five agents,
each that proposed different product ideas.
And then you could have like debate agents
that debate back and forth about why this
would not be a good idea.
And in doing so, they come to a consensus
and improve the quality of the product
at the end of the day.
So what this just did is it spun up
and listed all of the products here
so that it could build a simple and straightforward way
of basically splitting this work up.
So now we have 10 scanner agents that are running
in parallel across the code base.
This first one here has 83K lines.
The second one has 43, 42, 42, 35, 49.
So they're not all the same obviously,
but lines aren't all equal.
So maybe this did some additional work
behind the scenes or under the hood.
Now this is gonna consume a lot of tokens.
So see here, we're already at 1.3 million and counting.
And I'm consuming a fair amount
of my own token budget to do this,
but I figured it would just be interesting for us to do.
If you're operating at like a massive scale like this
with dozens, if not hundreds of these things,
you will eventually spend several thousand dollars
on said tokens.
And so you need to be prepared for that.
Don't spin up an unlimited number of agents
if you're not capable of paying the money
for upset unlimited number of agents, obviously.
And be wary that the tokens that you are using here
are tokens that unfortunately you will never get back.
You can't spin this thing up
and then ask for a refund on any of these.
So be careful, I guess, to make a long story short.
However, if you do have the money,
you can basically convert it
and translate it directly into time, as in time savings.
What I've done here is I've taken $1.3 million,
$1.3 million, 1.3 million Sonnet 4.5 tokens.
And I basically immediately translated them
for probably several hours of my time
because I don't actually have to go through this
or do this a lot slower with like a more intelligent agent.
So now that we've done this,
the next step is we've compiled
all of these security possibilities, I should say.
We're now spawning specific agents
all about particular security issues.
So we have a command injection and code execution agent,
an authentication and authorization agent,
a path traversal plus SSRF plus info disclosure agent,
crypto plus race conditions plus config agent,
challenges findings as not real issues
is devil number one, that's devil's advocate.
Then devil number two says,
argues findings are real and need fixing.
And so basically these agents
are all gonna report over to these puppies.
And these two are gonna debate back and forth
between each other to determine
whether or not this is something that's real,
whether or not this is something
that's actually super important.
They're gonna take different principled positions
and attempt to see whether these findings
are not real issues or whether these findings
are real and need fixing.
Usually when you have two agents work adversarially
against each other like this,
the end result is higher quality.
This is actually the core of a big chunk of machine learning,
which is what AI used to be called a few years back,
not just large language models,
generative adversarial networks
were one of the first image models, for instance,
and they worked in a very similar fashion.
You had something that generated
and then you had sort of like an adversary.
And these two just went back and forth and back and forth
until you got a really high quality result.
So I can actually scroll down here
and see what these two are saying.
So these are literally having a conversation right now.
These are actually discussing things.
Looking at devil number two,
it's sending round one, it's counter arguments now,
we're going back here.
And they're basically like fighting verbally mind you,
sticks and stones may break my bones,
but AI words will hurt you,
to determine which is the best path forward.
This message over here, this wasn't mine.
This was a message from the team lead.
Basically a devil number one responded to team lead saying,
Hey, here's a key finding.
Team leader responded back saying,
Hey, keep going and let me know when the debate finishes.
When it's done, we're good to go.
So to be clear here over the last, I don't know,
maybe 15 minutes or so
of the specific agent team instantiation,
I've spent close to probably 80 or so dollars
directly on this one query.
And that's what I mean by trading money for time.
I mean, like, obviously,
if I had a team of developers doing this,
they probably would have been more accurate,
but it also would have taken them presumably several weeks
to do the level of research that this agent
was capable of doing in just a few minutes.
I traded $80 for that time.
And so in some instances, that's worth it,
but in a lot of other instances, it isn't,
which is why agent teams need to be handled pretty carefully.
They're almost like a nuclear weapon,
just one aimed directly at your wallet.
Now we've done the debate back and forth.
The two have had a great conversation.
And so basically they found 15 total flaws.
What it's doing is it's now spawning 15 fixer agents,
one per isolated security issue
or group when they touch the same file.
Now I don't obviously want this to consume all of my tokens.
So I'm just going to cancel this and I'll say shut in caps,
shut everything down ASAP.
It's not gonna shut down all active agents immediately.
Unfortunately, just due to the nature of this,
the shutdown request doesn't occur immediately.
It's not just like we're, you know,
alt F foring this whole puppy.
There's a little bit of time because every individual agent
is still in the middle of a query
while it's doing the thing.
So, you know, you're probably still gonna consume
a little bit of token usage.
Not gonna be that crazy, but it is gonna be a little bit.
But yeah, you know, I've consumed enough at this point
to know that this is something
that I'm probably not gonna wanna do
unless I'm hell bent on improving the OpenClaw repo,
which I am not.
And that takes us to the final module in this course,
which is one on Git work trees.
Now, Git work trees used to basically be
what agent teams are today.
Essentially, you could have multiple agents all running
on their own individual,
what's called GitHub repo or GitHub branch.
And in doing so, these agents could all work
on individual features,
which allowed them to do what they needed to do
before ultimately merging back to the main branch.
To visualize this for you,
imagine we start with a job over here at main.
This is our main branch.
And then there's some bugs.
What we do is we spin up a branch called hotfix.
Now this is given to a different agent.
We then have another branch called develop,
which is given to a different agent.
Then finally, a branch called feature,
which is given to a different agent.
So basically what occurs is we have one agent over here,
extending on this branch,
one agent over here, extending on this branch,
one agent over here, extending on this branch,
and then one agent over here extending on this branch.
And essentially each of these go through
their own development process,
similar to the agent teams like we just saw here,
just managed through GitHub
instead of just the antigravity IDE.
And then when they're done,
what they do is they merge the results
back into the mage branch.
Now, if you're not a big into programming
and you haven't used GitHub before,
this idea of a merge can be pretty difficult to understand,
but basically every branch just stores a copy of the folder.
And so this master folder is basically the same thing
as this new feature folder
with just a couple of minor differences.
And it's usually the new feature itself.
So when you merge,
what you do is you're just tabulating a list
of all the changes between these two,
and then you're taking the new changes
from the new feature branch
and then applying them to the master branch.
This merge process can typically be pretty messy.
And so having agents around to mediate the merges
and so on and so forth can be quite useful.
So first of all, I have a really simple website set up here
called leftclick-agency.
I made this for my own website a while ago
and had AI do the vast majority of the work
in a very similar sort of workflow
to what I just showed you guys a moment ago with agent teams.
And what I wanna do is,
I wanna design additional pages here.
One page that's really long is not enough.
So in addition to this homepage,
I also wanna design an about page,
a contact page and a services page.
And I wanna use the Git WorkTree workflow
in order to do this.
Now, because I've stored information
on what I mean by Git WorkTree in my Claw.md,
which is basically that we use Git WorkTrees
for parallel development with Claude Code
where every WorkTree is an isolated working directory,
sharing the same Git history,
allowing multiple Claude Code instances
to work on different tasks simultaneously
that interference, okay?
This already knows what to do.
The very first thing that it did
was it basically took my main repository,
which was just called leftclick-agency,
and it made three different ones.
It made one called leftclick-agency-services,
that's a new folder.
Another called leftclick-agency-about,
which is another folder.
And then another called leftclick-agency-contact,
which is a third folder.
So basically what it's doing now
is it's creating new GitHub repositories,
new individual feature branches
to work on different pages for me.
Now it did this using the agent team functionality.
And the reason why I did this
is just because it's much faster
and they get to work on different GitHub repos
simultaneously.
The only real advantage to using Git WorkTrees,
I think at this point,
is just that when you use Git WorkTrees,
what you're doing is you're not actually
modifying the main folder.
Like if you look up here,
we're not actually modifying any of this right now.
What we're doing is we're basically creating
a new folder in our GitHub repository.
And you can see them right over here.
And then working in those different folders individually.
So for instance, we have leftclick-agency.
This one here is my main folder, right?
But then we have leftclick-agency-about.
This is a new branch that's working
specifically on the about.
Then we have contact.
This is a new branch working specifically
on the contact page.
And then finally we have services,
which is a new branch working specifically
on the services page.
And so the reason why this is valuable
to people that are non-programmers
is because you reduce the possibility
of two different agents working on the same file,
which will occur.
You will get what are called agent conflicts
over time naturally as you have multiple agents
working on multiple things in the same base.
And the reason why is because files
aren't perfect separations of functionality.
You know, you'll have one file
and then that file will have like the snippet
of a little bit of code that's used by another file
and so in that way, there's never like perfect separation.
So if an agent really wants to like totally encapsulate
a function or something, sometimes it'll have to dump
around from both.
And when that happens, it'll step on the toes
of another one.
So anyway, when you use work trees in this way,
you just eliminate that for being an option completely.
Basically, there's just no way that these two
can step on each other's toes
because they're actually all working
in separate folders simultaneously.
And because they work in separate folders,
that also means if they do make changes,
those changes don't always perfectly harmonize right away.
And that's where that merge step comes into play.
Basically, you know, now after we work
on these three different branches,
we also have to do is we need to unify them
through some sort of merge function.
You can see the prompt for the general purpose
services.html one here is you're building
the services.html page for left click agency,
work in the work tree at this folder,
create the file in here, don't modify the index.html.
You know, there's tons of information.
If I go back here, we'll see the same thing
for contact.html.
And so all you really need in order to have a workflow
like this that minimizes dependency risks,
is just have a cloud.md that outlines what to do
with get work trees.
I'll include this file down below
so you guys have everything that you need,
but taking a look at the about.html here,
which is one of the files that this thing
just whipped up for me.
You know, we've now basically finished the page.
It's used some placeholder little flasks here
because it wasn't sure what I wanted to do for images.
And you know, I can add however much information
I want here to really flesh it out.
Yeah, this looks pretty clean to me.
Our principal's ready to work with us.
Ooh, that's really clean.
I didn't realize I could do that.
Likewise with the contact.html page.
So now we have a beautiful contact.html page
with like a little, send us a message form
and so on and so forth.
I wonder if that works.
Wow, it even has some validation.
That's pretty neat.
Okay, and then after it's done,
what it'll do is it'll merge everything together.
So we also have services.html up here too,
which is really clean.
This looks like a real chunky page,
which probably explains why it took much longer.
And it looks like it even estimated some prices for them,
which is pretty nice.
So yeah, suffice to say, get work trees.
While not necessarily the end all be all,
can be an extra layer of insulation
if you guys are using something like, you know,
agent teams, or even if you guys are using sub agents,
just using some sort of merge functionality
like I talked about.
If you guys want more on that,
I'll include the cloud.md below
so you guys have everything that you need.
Okay, so we've talked a lot about using Claude Code
to build cool software apps and stuff like that.
The last thing I wanna talk about is basically just automating
or significantly streamlining the process
of deploying things to the internet.
You guys remember that first site that I made
and then the proposal generator and stuff like that?
I use a simple service called Netlify
to basically push my work live.
And that service works really well for static sites.
I'm not affiliated with them whatsoever, by the way,
use whatever the heck you want.
But what I wanna talk about next is using
something analogous to that just for backend functions
and skills and scripts and so on.
So what I'm gonna do here is I'm gonna whip up
open conversation, I'm gonna jump into bypass permissions
and I'm gonna say deploy a simple API endpoint
that returns happy birthday Nick if it's my birthday
or no birth to today MF if it's not.
And what I wanna do is I wanna show you guys
how easy it is to basically whip up your own URL
that does something for you.
This is more of an advanced feature for people
that are into automation and workflow building
and stuff like that.
But basically these services,
in my case I'm using one called modal,
allow you to whip up like publicly available endpoints
or publicly available URLs that you can use
and integrate within other applications.
A lot of the time applications will use things called
web hooks to send and receive information to and from them
to send events and trigger various pieces of functionality.
And this is a quick and easy way that you can basically
create a URL that does that for you,
as well as integrate it into things like no code platforms
like NADAN, make.com, Zapier, Lindy, et cetera.
So I have my endpoint right over here.
What I'm gonna do is I'm gonna take this curl,
which you may be wondering like
what the heck's going on over here?
I'm actually gonna open up my own terminal instance
and I'm gonna paste that in.
So basically what I've done, to make a long story short,
is I have generated my own API.
Zooming in here, what I've done is I've sent a request
to my own website, which was
nicholasriov-birthday-check-check-birthday.modelrun.
And then I sent some authorization credentials
and stuff like that.
And now it's sending me back a little message,
which is basically saying, no birthday today, MF,
because it's not my birthday.
So what I'm gonna do is I'm gonna go back here
and just to make it even clearer for you guys,
okay, this is awesome.
Remove the authentication.
I wanna be able to access this with my browser
using a simple get, and then I wanna have
like a cute little happy birthday or no birthday message.
What I'm gonna do now is I'm gonna show you that
this is analogous or equivalent to just a website.
And so what you can do as well is you can basically take
whatever you want, whatever piece of functionality,
and then immediately deploy like single URLs
that people can access to do things,
which you may not think is super important.
I just opened this up and we have our own little website
here, but as you saw there, I mean, all I did was
I literally sent like one little message and then boom,
it bumped this on, like made this a publicly
accessible website.
You can do this with anything.
You can do this with the websites that we've designed
so far, you can do this with the web apps
that we've designed so far.
And it's just like the simplest and easiest way
to get something web accessible,
whether you are giving a URL to somebody
to have them do something with,
creating some additional functionality in your app,
logging user visits for things like ad campaigns
and marketing campaigns, or doing direct connections
via web hooks and no code platforms like make.com,
and add in, et cetera.
So how do you do it?
My favorite service right now is one called modal.
This is basically marketed as AI infrastructure
that developers love.
It's super easy and straightforward to set up.
And every time you click on the page,
it expands this damn square thing,
which is super, super cool to look at.
I love cubes.
Clearly their team has spent a lot of time
in ownership designing this website.
I wonder if they use Claude Code.
Anyway, what you have to do first, you have to sign up.
So I'm just gonna go over here into an incognito tab.
I'm gonna pretend that I don't have an account yet.
Then I'm going to click sign up.
Then I'm going to continue with,
why don't we continue with Google?
Then I'm just gonna sign in.
Cool, we are now signing in.
And the very first thing that happens
is you'll have some little onboarding screen
that says welcome to modal.
So I'm just gonna say personal.
And how did we hear about us?
Social media, I don't know.
I just wanna use this for other.
Then I'll click get started.
What it's going to do now is it's gonna give me access
to all sorts of stuff.
And in the top right hand corner, as you see,
it's given us $5 in credits.
You can actually claim up to $30 in credits
just by doing a few additional little onboarding tasks,
adding a card and stuff like that.
I should note that I've been using modal
for quite a while now.
It's probably been a few months.
And I think I'm still at $4.50 of credit on my main account
where we probably have an API request
coming in every day or two.
So yeah, pretty cool stuff.
Definitely a lot of usage there with the $5.
It's way cheaper of a service, I wanna say,
than a lot of the no-code tools and automation platforms
that I was using before like make.com and N8n.
Over here, what you need to do is create an API token.
So I'm gonna click new token.
I'll say for, what did I actually have over here?
That was pretty interesting.
Not genuine.
Okay, let's do that.
And then we actually have the token.
So I'm just gonna copy the server.
And then what I wanna do is I just wanna paste this on.
And in the CLAW.md, there's instructions
where basically you can just give it a new token
and then it'll go and create all of the stuff for you.
So I'm gonna include this in the description down below.
You guys can take a peek at this.
If you're new to this, all you have to do
is just do what I just showed you.
And then now you have the ability
to basically run this on any account.
And you know this because this new URL
that I just popped up here,
this is on a different service now.
It's on my Nick J. Wells account,
not my Nicholas Sariath account,
which I was on just a moment ago.
But let's say you wanna extend this.
You don't just wanna do a simple URL that, I don't know,
like tells you whether or not it's your birthday.
You actually wanna do something for business purposes.
Well, here's where things get really interesting.
What you can do is you can take a skill
that you've developed before.
Then you can just put it up on a URL.
So that every time you or somebody else accesses URL,
it immediately triggers the workflow.
Let me show you what I mean.
Remember how when we chatted about skills,
I have this one called scrape leads?
What if I just copy this
and then paste this directly into this folder?
I'm also going to wrap it in a .clod
and then a skills folder just for organization sake,
because I could tell this is probably gonna get
pretty complex if I don't.
Okay, and now I have it
inside of .clod slash skills slash scrape dash leads.
Now what I'm gonna do is I'm gonna say,
this is great.
What I'd like you to do now is I'd like you
to put the scrape dash leads workflow online.
I want to be able to access it via a simple URL.
Basically, when I access scrape dash leads,
I want a little form to pop up
and ask me what I wanna scrape.
I then fill out that form
and then you execute the scrape dash leads workflow
and then return me the leads in a CSV file when it's done.
And this has taken us probably less than two minutes
in total.
I just filled out the request.
We now have a URL.
Just gonna open up this URL,
which is as mentioned the same as any other URL.
The search query I'm gonna do is I'll just do dentist.
I'll say United States.
We want, I don't know, 100 results.
Let's make it really small.
Now that we've clicked,
we're just gonna take a few minutes to do the actual scrape.
The instructions I gave it were to immediately download
the CSV right as this is done.
Okay, and then top right hand corner,
I have my leads underscore dentist 100.
So I'm just gonna take a peek at this
and we have the data right over here.
Okay, looking pretty good.
We have 100 leads.
Most of these look like dentists, if not all.
We also have a bunch of additional data about them,
which is pretty bad ass.
So I could use this to build a really cool campaign.
And yeah, hopefully you guys now see the power
in having something as simple as modal available
to both whip up really quick webpages and internal tooling
and even some external tooling,
as well as use this to do things like run workflows, right?
You can build your own API call
or build your own API endpoint, I should say,
really just a couple of keystrokes.
And that's that.
I hope you guys enjoyed learning everything
and anything to do with Claude Code today.
You now have everything that you need
to build the foundational base of knowledge,
whether or not you guys are programmers
or completely non-technical people coming into this
to learn how to do things like build simple apps,
websites, or workflows.
I had a blast teaching you guys this sort of stuff.
If you've ever wondered how to monetize work like this,
whether it is custom app development or workflow building,
I'd definitely check out Maker School.
It's my 90-day accountability program
where I guide you through step-by-step
and quite literally every single day
through a sequence of actions necessary
to get you your very first customer.
And I also guarantee that you get your first customer
by the end of a 90-day period.
If you don't, I give you all your money back.
That's my last and only pitch of this video.
Aside from that, I hope you guys like what you saw.
If you guys have any questions
or need help with anything that I mentioned in the video,
just drop it as a comment down below.
Aside from that, have a lovely rest of the day,
and I'll catch all y'all in my next course.
Bye.