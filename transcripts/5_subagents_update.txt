Alright, so after about two weeks, we're 
back with more Claude Code updates and I'm  
gonna go through most of the features 
that were released about an hour ago,  
of which there are quite a few. Anyways, this 
video is sponsored by myself and my Claude Code  
Masterclass. There is a new year sale going on 
right now and there will be a link down below,  
but it's basically the most comprehensive class 
on Claude Code that you will find on the internet.
Many people have taken the class and gone on to 
be the best Claude Code users at their company,  
so you may also find it helpful. Anyways, the 
first feature that caught my eye is running skills  
and slash commands in forked subagent contexts. 
Using this thing in the skill frontmatter.
So basically the way that this works is that 
if you go to any of your Claude Code skills,  
so for example, if I go to my GitHub 
release notes skill, then at the very top,  
I can add this to the skill frontmatter. So 
it looks like this context fork. And when I  
then run that skill, it will then 
run that skill within a subagent.
So let's make sure Claude Code is 
updated to correct version `claude  
update`. Can you run the GitHub 
release notes generator skill from  
2.16.1 till now? And then Claude Code 
will ask me if it can use the skills.
So press yes. And now you can see the skill 
is running within a separate context window  
because the amount of tokens that it's using 
is not going up in the main session. And now  
that it is done, you can see the token count 
only increase slightly compared to before,  
where if it was running in the main session, 
then it would basically like use a lot of  
tokens because this skill is looking through 
a lot of files within the commit history.
So anyways, for any of the skills of yours 
that can end up eating a lot of context in  
the main session, if you add this to very top 
context fork, then it will run within a separate  
context window where like a subagent does. Now, 
one advantage is that if you make this change,  
previously if you made a change to skill or made 
a new skill, you'd have to restart Claude Code,  
but now you don't have to because it's like 
automatically monitoring any changes that  
are happening. Now, this should also work with 
specifying the model in the skill frontmatter,  
where if you don't have a model specified, 
then it uses the model of the main session.
But if you do, then it uses that 
particular model instead. And in  
that case, it can run faster 
if you're using a lighter,  
faster model. And of course, you can find 
the model aliases by going on this page.
They also added support for an agent field 
and skills to specify the agent type for  
execution. And after a bit of experimentation 
with this feature to figure out how it works,  
basically you need to have the context 
fork enabled on your skill frontmatter  
and then any of the subagents that are 
available in Claude Code. So for example,  
I have a macOS log analyzer 
subagent that is a Haiku subagent.
If you then specify this in a skill, 
such as this example find to do skill,  
what will happen is it will first 
spin up that particular subagent.  
With all the information you provided to 
subagent as the system prompt. And then  
after it launches as subagent, it will 
trigger the skill within the subagent.
And this should not be confused with the reverse 
behavior where you can get subagents to use  
and trigger skills by passing in the skills 
that the subagents should have access to into  
subagent frontmatter by doing something 
like skills and then your skill names,  
which is like find to do and like GitHub release 
notes. You can get Claude Code to now reliably  
respond in a different language by adding a 
language parameter to your settings file. So  
I can do like Japanese for example, and then 
running Claude, tell me a story for example,  
it will then give the output in Japanese 
for whatever story that it comes up with.
Okay, now the next one is pretty 
interesting because subagents can  
now have their own hooks from pretool use, 
posttool use, and stop hooks. And this also  
applies to skills and slash commands. So 
essentially it looks kind of like this.
You would have your usual like 
subagent name, description,  
and then you define hooks over here. So 
pretool use, posttool use if you want to  
and stop. You define any matches that would be 
required, and then what exactly the hook does.
Okay, so here's a quick example. We 
have a Cloudflare deploy subagent,  
which has a couple hooks over here. And 
this is for my application, HyperWhisper.
There will be a coupon code down below, 
and it's for the cloud version of the  
application. So it's hosted on 
Cloudflare Workers. So basically  
what happens before it deploys is it will 
check whether the types compile properly.
After it deploys, it will then do a quick 
health check, depending on whether deployed  
to dev or prod. Using this health check 
URL. And then finally it will send me a  
notification using AppleScript on my computer 
saying that the deployment has been completed.
And here is where I call the Cloudflare deploy 
subagent. And before doing the deploy, it does  
a check to make sure the types work properly. 
And then after calling the deploy command,  
it then does a health check right down over here 
to make sure it works, and then passes that back  
to main session where like deployment is 
complete, the health check and so forth.
I made a similar one for macOS notarization. So 
if I go through this, I can just tag the macOS  
notarization subagent, press enter. So you can see 
that it actually finished early because I did not  
specify which file I want notarizing, but it did 
send me a notification on my computer over here.
So you can see that previously we had hooks 
that were in the `settings.json` file and  
that would run for all tasks. But now we 
can make agent scoped hooks by defining in  
the frontmatter of each agent and then also 
do for skills and slash commands as well.
So basically you could have like a deploy 
subagent that would then like auto validate  
stuff and do health check like I just showed. 
You can make a research explore subagent that  
would basically block any write operations 
within a specific directory on your computer,  
for example. And you can basically 
have like test runner subagents.
If you have a lot of tests in your code 
base, you could split up 100 tests across  
10 different test runner subagents and then 
capture the results of any tests that failed  
by using one of these hooks and then pass it 
back to main session to then investigate why  
that particular test has failed. Now, those 
are just a few of the ideas I have had so far,  
but I'm sure many people will be coming up 
with more ideas of how this can be used. Claude  
Code now also has a specialized subagent 
when it comes to running batch commands.
So if you do @, then you can type in 
bash and you can see the specialized  
subagent right over here. So I can say like 
`npm run build` in the Next.js application.
Then it will spawn up that particular 
subagent, run through all the bash  
commands that are required, and then it will 
give the final result back to main session,  
which keeps the main session's context 
window clean. And then I can move this to the  
background by doing `control B`. And as I showed 
earlier, I can combine it with other things.
So for example, my macOS appcast generator 
skill, I can just add like agent type in bash  
and then it will use the specific bash sub-agent 
that's specialized to running bash commands. So I  
would probably use this for bash commands that are 
even multi-step or can take up a lot of context.  
So for example, I could make myself a new 
skill that sets up Docker and installs relevant  
dependencies and does a bunch of other things 
and that can be assigned to a bash sub-agent.
There's now wildcard pattern matching at any 
position. So if you go to your settings file,  
for example, then I already have it right over 
here. So it can do any `npm install` command.
If I wanted to allow any install command, 
then I can just put a wildcard at the front  
and then it would allow that. I can also do 
the same thing with git commands, for example,  
as well, by doing like a `git` and then 
asterisk. When you press `control B`,  
then I will now move all bash commands 
and subagents to background at once.
So if I run five explore subagents simultaneously, 
then you can see they're all running in the  
foreground right now and I can press `control B` 
and then all five of them have moved to background  
right now. And this basically means that you 
can continue chatting with Claude Code whilst  
things are still running in the background. 
They added a slash `remote-env` command.
So if you do `remote-env`, press enter, then 
you can see these are the remote environments  
that I have. And basically they are the exact 
same environments that I see when I go to the  
Claude Code desktop or Claude Code in the 
cloud. And I can make a new one over here,  
put in the environment variables and so 
forth, and then it should appear in this list.
So if I change this to default, for example,  
and then move a command to background by doing 
`&` then I'm typing in the prompt, for example,  
and that will then go to Claude to that remote 
version. Instead of deleting unused subagents,  
you can disable them by adding this to your 
deny list in your `settings.json` file.
So for example, I can just call this like 
`macos-notarize` and this subagent will  
no longer be available to Claude Code. 
You can also now enable planning mode  
by doing `/plan` and that will turn it 
on. And if you do `/plan` again in plan  
mode and you created a plan earlier, 
then it will show you the same plan.
They now added support for once for hooks, which 
basically means a hook will only run once the  
first time it is matched and won't run again on 
successive matches. And you can just enable it  
by doing like for example, `once: true` anywhere 
you're using hooks. They have now added a real  
time thinking block display in transcript mode, 
which basically means that if you press `control  
O`, then you can see like right over here, this 
is what the agent is thinking about right now.
And then it changed to slash context, they 
added skills, which basically means that  
you can see roughly how much tokens your 
skills are now taking up. So previously  
when a sub agent would ask you whether it 
can use a tool or permission, for example,  
and you press no, then the sub agent would just 
stop there completely. Now if you press no,  
then the subagent will try different 
approaches and continue working.
You can now trigger skills as slash commands 
by doing like just a skill name. So I can do  
`github-release-notes`, press enter, and 
then it will start running that particular  
skill. And whilst the skill is running, I can 
see what kind of tools that it is calling.
For example, these logging tools 
and diff tools. And if I do slash,  
I can see my skills and these are ordered by how 
frequently they are used. When it comes to things  
that have tabs like slash stats, I can use my 
arrow keys to go back and forth between the two.
Rather than pressing tab to cycle. They now 
fixed the escape key with queued prompts.  
So basically what would happen is 
that if you queued some messages,  
if I press escape, then it will 
remove that last message from the  
queued prompts and it won't actually cancel 
task unless the prompt has gone into task.
Whereas previously it would like unqueue 
that message and then also cancel a task,  
which is like not what you wanted. When it 
comes to using terminals like Ghostty or iTerm,  
you can move onto new lines quite 
easily by just pressing shift enter.  
Without having to change like any 
configuration as you did before.
And also the creator of Claude Code said 
because thinking is on by default everywhere,  
UltraThink doesn't really do 
anything anymore. So for example,  
like Claude Code desktop that has thinking 
on by default. And then he'd say is that  
UltraThink can only be useful if you 
have thinking turned off by default.
Because then if you put it in that prompt, it 
will turn on thinking just for like solving  
that particular problem. Anyways, 
I'll now be updating my Claude Code  
Masterclass with a lot of information 
that I briefly mentioned, but in more  
detail. So if you want to do get better at 
using Claude Code, then do check that out.
There will be a link down below with 
a coupon code. And something else I  
have been thinking about recently is the 
fact that Anthropic will most likely end  
up introducing something this year that will 
account or like make multi-Claude Code agent  
orchestration easier. So many people have 
been making their own tools around this,  
like Gas Town, for example, and that allows you 
to run many Claude Code instances in tandem.
There are other tools like, I think, AutoClaude 
and like Claude Kanban Board and stuff like that.  
Basically a lot of people are making like random 
tools around this like domain and no one exactly  
knows what correct or the final form of like this 
multi agent orchestration thing you will take. So  
I imagine that Anthropic will be introducing 
something to do with that later this year.
And basically what makes me think this is 
that someone shared a like system prompt  
from one of the preview versions of Claude 
Code. I think this has now been removed,  
but you can basically see that like 
you can spawn teammates and messages,  
team coordination, like add a task update 
to the team. So they have this like kind  
of idea of teammates that may be baked 
into into Claude Code in the future.
And this has kind of happened before 
with Claude Skills, for example,  
or MCP. Some serious users were kind of 
playing around with things and making  
their own GitHub libraries like Gas Town. 
And then Anthropic basically comes up with  
their own official way of doing something 
that's adopted by the rest of the industry.
Anthropic just seemed pretty good at making 
these format standards protocols that seem  
pretty well adopted by everyone else. So I 
imagine they will be coming up with something  
this year about like multi agent orchestration 
in a way. And whatever they do come up with,  
I imagine will end up being the 
default for many like coding CLI  
tools and it will probably be available 
in Claude Code before any of a CLI tool.
Anyways, I do kind of share 
my thoughts on this kind of  
stuff in my AI newsletter that will be 
linked down below if you are interested.